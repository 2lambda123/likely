\documentclass[numbers=noenddot]{scrbook}

% The Likely tokenizer will look for the use of the "likely" environment to
% determine what parts of the document are Likely source code.
\newenvironment{likely}
{ \verbatim }
{ \endverbatim }

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{verbatim}

\newtheoremstyle{dotless}{}{}{\itshape}{}{\bfseries}{}{ }{}

\renewcommand{\arraystretch}{1.2} % more space between table rows

\lstset{basicstyle=\ttfamily,
  showstringspaces=false
}

\newcommand{\noun}[1]{\textsc{#1}}
\newcommand{\fref}[2]{\href{#1}{#2}\footnote{\href{#1}{#1}}}

\title{The Likely Programming Language \\
       {\large Language Reference and Standard Library}}
\author{Joshua C. Klontz}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

\chapter{Introduction}
\fref{http://www.liblikely.org/}{\noun{Likely}} is a programming language for image processing and statistical learning algorithm development.
A special emphasis in Likely is given to the execution of algorithms on parallel and heterogenous hardware architectures.

The goal of Likely is concise yet ambitious, \emph{to revolutionize computer vision algorithm design and deployment}.
With this goal in mind, the following sections discuss the guiding design decisions behind Likely.

\section{Embeddable Compiler}
Likely is foremost a software library.
Both the \fref{https://s3.amazonaws.com/liblikely/doxygen/console\_interpreter\_compiler.html}{\emph{likely} console-interpreter-compiler} and \fref{https://s3.amazonaws.com/liblikely/doxygen/integrated\_development\_environment.html}{\emph{dream} integrated development environment} are built on top of the \fref{https://s3.amazonaws.com/liblikely/doxygen/index.html}{Likely C API}.

Understandably, there is more involved in deploying a computer vision application than applying algorithms to pixels alone.
Likely is designed to excel at pixel transformations, while leaving the remaining application logic for implementation in the developer's preferred programming language.

It was with this focus on an embeddable compiler that the domain name \url{liblikely.org} was chosen.

\section{Compile-Time Function Evaluation}
Compile-time function evalutation (CTFE) is a core tenant of Likely programming language.
Likely rejects the notion of training a statistical learning model as an offline step after algorithm compilation.
Instead, \emph{Likely formulates statistical learning as the compile-time evalutation of a function} (the learning algorithm) \emph{with constant arguments} (the training data).
We believe that compile-time knowledge of the statistical model will open the door to interesting \fref{https://github.com/biometrics/likely/issues/20}{optimization opportunities}.

Likely leverages the \fref{http://llvm.org/}{\noun{Low Level Virtual Machine}} (LLVM) project for both static and just-in-time (JIT) compilation.
One particularly salient use of the JIT compiler is for CTFE, as the JIT compiler automatically leverages all instruction set extensions and coprocessors available at runtime.
In the special case where the function to be executed does not have loops, Likely will instead run an interpreter which has been found to be faster for executing simple code.

A computer vision algorithm is a series of image processing and statisical learning transformations that require incoming samples conform to particular type and dimensionality expectations.
Likely exploits these expectations by conducting \emph{type inference using the output of functions evaluated at compile time}.
Though algorithms are often written without specifying parameter types, they are still statically compiled because CTFE output dictates input type, and often dimensionality as well.
This is in contrast to conventional computer vision libraries which, lacking compile-time knowledge of the particular algorithm of interest, provide parameter type generality by branching at runtime.
Branching that is unnecessary for any particular algorithm where all runtime samples are expected to branch along the same path.

\section{Portability}
Likely is written using a portable subset of \noun{ISO C++11}, which means it can \fref{http://llvm.org/docs/GettingStarted.html\#hardware}{run everywhere LLVM does}.
Algorithms execute natively on single CPU threads via the LLVM \noun{Machine Code JIT} compiler, multi-core CPUs via a custom \noun{OpenMP}-like backend, and GPUs and coprocessors via \fref{https://github.com/biometrics/likely/issues/24}{\noun{CUDA}} or \fref{https://github.com/biometrics/likely/issues/25}{\noun{OpenCL}}.

Likely algorithms can be \fref{http://liblikely.org/share/likely/hello\_world/hello\_world\_static.c}{statically compiled to native object files}, \fref{http://liblikely.org/share/likely/hello\_world/hello\_world\_jit.c}{just-in-time compiled for dynamic applications and scripts}, integrate into \fref{https://github.com/biometrics/likely/issues/46}{other languages}, published as \fref{https://github.com/biometrics/likely/issues/44}{web services}, and even transcompiled into single \fref{https://github.com/biometrics/likely/issues/51}{\noun{C}} or \fref{https://github.com/biometrics/likely/issues/45}{\noun{JavaScript}} source files.

\section{Live Coding}
Developing computer vision algorithms is a creative process, and like all creative processes it relies on immediate visceral feedback through interaction with the creative medium.
Algorithms have numerous parameters, and visualizing their effects is critical to building intuition and making improvements.
The computer vision domain and Likely's library design are well suited for \emph{live coding} popularized by \fref{http://worrydream.com/}{Bret Victor}.
In fact, Likely's accompanying IDE called \emph{dream}, is \fref{https://www.youtube.com/watch?v=a\_hz8wFACVM}{designed from the ground up to support interactive algorithm development}.

\section{Literate Programming}
Likely is a \fref{http://www.literateprogramming.com/}{literate programming} language.
In addition to serving as the reference manual for the programming language and standard library, \fref{https://github.com/biometrics/likely/blob/gh-pages/library/standard.tex}{\emph{is document also contains the source code for the Likely standard library}}.

Likely recognizes both \fref{https://help.github.com/articles/github-flavored-markdown}{GitHub Flavored Markdown} (GFM) and \fref{http://www.latex-project.org/}{\LaTeX} syntax, and will automatically extract source code from appropriately marked blocks.

\part{Language Reference}
\chapter{Abstract Syntax Trees}
\section{Prefix Notation}
Likely is a member of the \noun{Lisp} family of languages, accepting fully-parenthesized prefix notation, also called \emph{s-expressions}.

\theoremstyle{dotless}
\newtheorem*{PN}{Prefix Notation \nopunct}
\begin{PN}
$\boldsymbol{(} operator\ operand_1\ operand_2\ \dots\ operand_N \boldsymbol{)}$
\end{PN}

For example:

\begin{lstlisting}[language=bash, caption={Prefix notation example.}, captionpos=b]
$ likely -c "(+ 1 2)"
3
\end{lstlisting}

An important property of s-expressions is that they are equivalent to the compiler's \emph{abstract syntax tree} (AST).

\section{Special Tokens}
Likely recognizes three special tokens that influence how source code is parsed into an AST.
These tokens allow the developer to selectively depart from prefix notation to improve code readability.
These special characters and parenthesis are the \emph{only} tokens that need not be separated by a space.

\begin{table}[h]
\centering
\begin{tabular}{@{} l l @{}}
\toprule
Token & Name    \\ \midrule
;     & Comment \\
.     & Compose \\
:     & Infix   \\
\bottomrule
\end{tabular}
\caption{Likely special characters.}
\end{table}

When in doubt, you can print the AST to see how source code is parsed:
\begin{lstlisting}[language=bash, caption={Printing the abstract syntax tree.}, captionpos=b]
$ likely -ast -c "1 :+ 2"
(+ 1 2)
\end{lstlisting}

\section{; Comment}
The semicolon and all following tokens through the end of the line are excluded from the AST.

\begin{verbatim}
(this is some code) ; This is a comment
(+ 1 2) ; One plus two is three
(sq 3)  ; Three squared is nine
\end{verbatim}

\section{. Compose}
The expression to the left-hand-side (LHS) of the period is inserted as the first operand of the expression to the right-hand-side (RHS) of the period.
Compose is \emph{left-associative}.

\begin{verbatim}
x.f     ; Parsed as (f x)
x.f.g   ; Parsed as (g (f x))
x.(f y) ; Parsed as (f x y)
(f x).g ; Parsed as (g (f x))
(g x.f) ; Parsed as (g (f x))
7.2     ; Parsed as 7.2
3.sq    ; Evaluates to 9
1.(+ 2) ; Evaluates to 3
\end{verbatim}

We might call the third example \href{http://www.drdobbs.com/cpp/uniform-function-call-syntax/232700394}{uniform function call syntax}.
Note how this transformation does not apply to numbers!

\section{: Infix}
The expression to the RHS of the colon is the operator.
The expression to the LHS of the colon is the first operand.
The second expression to the RHS of the colon is the second operand.
Infix is \emph{right-associative}.

\begin{verbatim}
x:f y       ; Parsed as (f x y)
z:g x:f y   ; Parsed as (g z (f x y))
x:f (g y)   ; Parsed as (f x (g y))
x.f:h y.g   ; Parsed as (h (f x) (g y))
(g x:f y)   ; Parsed as (g (f x y))
1:+ 2       ; Evaluates to 3
3.sq:+ 4.sq ; Evaluates to 25
\end{verbatim}

Note how \emph{infix} has lower precedence than \emph{compose}.

\chapter{Literals}
At the lowest level of interpretation, every atom is either a \emph{number}, \emph{string}, \emph{type}, or \emph{intrinsic operator}.

\section{Number}
A number is a series of digits with an optional leading negative sign (-) and optional containing decimal point (.).

\begin{verbatim}
42    ; A number
-0.42 ; A number
.42   ; Not a number
0.42- ; Not a number
\end{verbatim}

\section{String}
A string is a series of characters enclosed in quotation marks (").

\begin{verbatim}
"hello world" ; A string
'hello world' ; Not a string
\end{verbatim}

\section{Type}
Types are special keywords indicating how data is represented.
Let's start with a few examples:

\begin{verbatim}
i16 ; 16-bit signed integer scalar
u32 ; 32-bit unsigned integer scalar
f64 ; 64-bit floating-point real scalar
f32C ; 32-bit floating-point real multi-channel matrix
u8XY ; 8-bit unsigned integer multi-column multi-row matrix
\end{verbatim}

The general, types are recognized by the following regular expression:

\begin{verbatim}
[uif]\d+P?S?C?X?Y?T?
\end{verbatim}

The first character indicates the element type, and is one of:

\begin{itemize}
\item \emph{u} - Unsigned integer
\item \emph{i} - Signed integer
\item \emph{f} - Floating-point real
\end{itemize}

The next one-or-more decimal characters indicate the element depth, and should generally be a power of two.

The remaining capitalized characters indicate:

- **P** - Type is a pointer.
- **S** - Perform saturated arithmetic when using this type.
- **C** - Multi-channel matrix.
- **X** - Multi-column matrix.
- **Y** - Multi-row matrix.
- **T** - Multi-frame matrix.

Additionally, the following special cases are recognized as types: \emph{void}, \emph{depth}, \emph{floating}, \emph{array}, \emph{signed}, \emph{saturated}, \emph{element}, \emph{multi-channel}, \emph{multi-column}, \emph{multi-row}, \emph{multi-frame}, \emph{multi-dimension}, \emph{string}, \emph{native}.
These special cases correspond to values of \emph{likely\emph{type}mask} in the C API.

\section{Intrinsic Operator}
An intrinsic operator is the basic construct for higher order expressions on numbers, strings and types.
The following section details all available intrinsic operators.

\chapter{Intrinsic Operators}
Likely has the following builtin operators.

\section{Arithmetic}
\paragraph{(+ \emph{lhs} \emph{rhs})}
The addition of \emph{lhs} by \emph{rhs}.

\begin{verbatim}
(+ 2 2)     ; Evaluates to 4
(+ 1.8 2)   ; Evaluates to 3.8
(+ 1.8 2.1) ; Evaluates to 3.9
(+ 1.8 2.2) ; Evaluates to 4
\end{verbatim}

\paragraph{(- \emph{lhs} [\emph{rhs}])}
The subtraction of \emph{lhs} by \emph{rhs}.
If \emph{rhs} is not provided then the negation of \emph{lhs}.

\begin{verbatim}
(- 3 2)     ; Evaluates to 1
(- 2 3)     ; Evaluates to -1
(- 3.2 2)   ; Evaluates to 1.2
(- 3.2 2.1) ; Evaluates to 1.1
(- 3.2 2.2) ; Evaluates to 1
(- 1)       ; Evaluates to -1
(- -1.1)    ; Evaluates to 1.1
\end{verbatim}

\paragraph{(* \emph{lhs} \emph{rhs})}
The multiplication of \emph{lhs} by \emph{rhs}.

\begin{verbatim}
(* 1 2)     ; Evaluates to 2
(* 1.3 2)   ; Evaluates to 2.6
(* 1.4 2.1) ; Evaluates to 2.94
(* 1.5 2.0) ; Evaluates to 3
\end{verbatim}

\paragraph{(/ \emph{lhs} \emph{rhs})}
The division of \emph{lhs} by \emph{rhs}.

\begin{verbatim}
(/ 4 2)     ; Evaluates to 2
(/ 4.5 2)   ; Evaluates to 2.25
(/ 4.5 2.5) ; Evaluates to 1.8
(/ 4.2 2.1) ; Evaluates to 2
\end{verbatim}

\paragraph{(\% \emph{lhs} \emph{rhs})}
The remainder after division of \emph{lhs} by \emph{rhs}.

\begin{verbatim}
(% 7 3)      ; Evaluates to 1
(% 6 3)      ; Evaluates to 0
(% 6.5 3)    ; Evaluates to 0.5
(% -6.5 3)   ; Evaluates to -0.5
(% 6.5 -3)   ; Evaluates to 0.5
(% -6.5 -3)  ; Evaluates to -0.5
(% 6.5 7.5)  ; Evaluates to 6.5
(% 6.5 3.25) ; Evaluates to 0
\end{verbatim}

\section{Comparison}
\paragraph{(== \emph{lhs} \emph{rhs})}
One if \emph{lhs} equals \emph{rhs}, zero otherwise.

\begin{verbatim}
(== 2 2)   ; Evaluates to 1
(== 2 2.0) ; Evaluates to 1
(== 2 -2)  ; Evaluates to 0
(== 2 2.1) ; Evaluates to 0
\end{verbatim}

\paragraph{(!= \emph{lhs} \emph{rhs})}
One if \emph{lhs} does not equal \emph{rhs}, zero otherwise.

\begin{verbatim}
(!= 3 3)   ; Evaluates to 0
(!= 3 3.0) ; Evaluates to 0
(!= 3 -3)  ; Evaluates to 1
(!= 3 3.1) ; Evaluates to 1
\end{verbatim}

\paragraph{(< \emph{lhs} \emph{rhs})}
One if \emph{lhs} is less than \emph{rhs}, zero otherwise.

\begin{verbatim}
(< 4 5)    ; Evaluates to 1
(< 4 -5.0) ; Evaluates to 0
(< 4 4.0)  ; Evaluates to 0
\end{verbatim}

\paragraph{(<= \emph{lhs} \emph{rhs})}
One if \emph{lhs} is less than or equal to \emph{rhs}, zero otherwise.

\begin{verbatim}
(<= 4 5)    ; Evaluates to 1
(<= 4 -5.0) ; Evaluates to 0
(<= 4 4.0)  ; Evaluates to 1
\end{verbatim}

\paragraph{(> \emph{lhs} \emph{rhs})}
One if \emph{lhs} is greater than \emph{rhs}, zero otherwise.

\begin{verbatim}
(> 6 7)    ; Evaluates to 0
(> 6 -7.0) ; Evaluates to 1
(> 6 6.0)  ; Evaluates to 0
\end{verbatim}

\paragraph{(>= \emph{lhs} \emph{rhs})}
One if \emph{lhs} is greater than or equal to \emph{rhs}, zero otherwise.

\begin{verbatim}
(>= 6 7)    ; Evaluates to 0
(>= 6 -7.0) ; Evaluates to 1
(>= 6 6.0)  ; Evaluates to 1
\end{verbatim}

\section{Bit Manipulation}
\paragraph{(\& \emph{lhs} \emph{rhs})}
Bitwise and of \emph{lhs} and \emph{rhs}.

\begin{verbatim}
(& 1 2) ; Evaluates to 0
(& 1 3) ; Evaluates to 1
\end{verbatim}

\paragraph{(| \emph{lhs} \emph{rhs})}
Bitwise or of \emph{lhs} and \emph{rhs}.

\begin{verbatim}
(| 1 2) ; Evaluates to 3
(| 1 3) ; Evaluates to 3
\end{verbatim}

\paragraph{(\^{} \emph{lhs} \emph{rhs})}
Bitwise exclusive or of \emph{lhs} and \emph{rhs}.

\begin{verbatim}
(^ 1 2) ; Evaluates to 3
(^ 1 3) ; Evaluates to 2
\end{verbatim}

\paragraph{(<< \emph{lhs} \emph{rhs})}
Left shift of \emph{lhs} by \emph{rhs} bits.

\begin{verbatim}
(<< 2 0) ; Evaluates to 2
(<< 2 1) ; Evaluates to 4
\end{verbatim}

\paragraph{(>> \emph{lhs} \emph{rhs})}
Right shift of \emph{lhs} by \emph{rhs} bits.
Arithmetic right shift (sign extension) if \emph{lhs} is signed, logical right shift (zero extension) otherwise.

\begin{verbatim}
(>> 2 0)  ; Evaluates to 2
(>> 2 1)  ; Evaluates to 1
(>> 2 2)  ; Evaluates to 0
(>> -2 0) ; Evaluates to -2
(>> -2 1) ; Evaluates to -1
\end{verbatim}

\section{Math}
\paragraph{(sqrt \emph{x})}
The square root of \emph{x}.

\begin{verbatim}
(sqrt 2)   ; Evaluates to 1.41421
(sqrt 2.1) ; Evaluates to 1.44914
(sqrt 4)   ; Evaluates to 2
(sqrt 0)   ; Evaluates to 0
\end{verbatim}

\paragraph{(sin \emph{x})}
The sine of an angle of \emph{x} radians.

\begin{verbatim}
(sin 0)         ; Evaluates to 0
(sin 1.570796)  ; Evaluates to 1
(sin -1.570796) ; Evaluates to -1
(sin 0.523599)  ; Evaluates to 0.5
\end{verbatim}

\paragraph{(cos \emph{x})}
The cosine of an angle of \emph{x} radians.

\begin{verbatim}
(cos 0)        ; Evaluates to 1
(cos 3.141593) ; Evaluates to -1
(cos 1.047198) ; Evaluates to 0.5
\end{verbatim}

\paragraph{(pow \emph{base} \emph{exponent})}
The \emph{base} raised to the power \emph{exponent}.

\begin{verbatim}
(pow 2 3)     ; Evaluates to 8
(pow 2 -3)    ; Evaluates to 0.125
(pow -2 3)    ; Evaluates to -8
(pow 1.5 0.5) ; Evaluates to 1.22474
(pow 2 0.5)   ; Evaluates to 1.41421
(pow 4 0.5)   ; Evaluates to 2
(pow 4 0)     ; Evaluates to 1
\end{verbatim}

\paragraph{(exp \emph{x})}
The base-e exponential function of \emph{x}, which is e raised to the power \emph{x}.

\begin{verbatim}
(exp 0)   ; Evaluates to 1
(exp 1)   ; Evaluates to 2.71828
(exp 1.5) ; Evaluates to 4.48169
\end{verbatim}

\paragraph{(exp2 \emph{x})}
The base-2 exponential function of \emph{x}, which is 2 raised to the power \emph{x}.

\begin{verbatim}
(exp2 0)   ; Evaluates to 1
(exp2 1)   ; Evaluates to 2
(exp2 0.5) ; Evaluates to 1.41421
(exp2 3)   ; Evaluates to 8
\end{verbatim}

\paragraph{(log \emph{x})}
The natural logarithm of \emph{x}.

\begin{verbatim}
(log 1)        ; Evaluates to 0
(log 2.718281) ; Evaluates to 1
(log 7.389056) ; Evaluates to 2
(log 0.5)      ; Evaluates to -0.693147
\end{verbatim}

\paragraph{(log10 \emph{x})}
The common (base-10) logarithm of \emph{x}.

\begin{verbatim}
(log10 1)   ; Evaluates to 0
(log10 10)  ; Evaluates to 1
(log10 100) ; Evaluates to 2
(log10 0.5) ; Evaluates to -0.30103
\end{verbatim}

\paragraph{(log2 \emph{x})}
The binary (base-2) logarithm of \emph{x}.

\begin{verbatim}
(log2 1)   ; Evaluates to 0
(log2 2)   ; Evaluates to 1
(log2 4)   ; Evaluates to 2
(log2 0.5) ; Evaluates to -1
(log2 10)  ; Evaluates to 3.32193
\end{verbatim}

\paragraph{(copysign \emph{x} \emph{y})}
A value with the magnitude of \emph{x} and the sign of \emph{y}.

\begin{verbatim}
(copysign 3 -1.1) ; Evaluates to -3
(copysign -4.3 2) ; Evaluates to 4.3
\end{verbatim}

\paragraph{(floor \emph{x})}
The largest integral value that is not greater than \emph{x}.

\begin{verbatim}
(floor 2.3)  ; Evaluates to 2
(floor 3.8)  ; Evaluates to 3
(floor 5.5)  ; Evaluates to 5
(floor -2.3) ; Evaluates to -3
(floor -3.8) ; Evaluates to -4
(floor -5.5) ; Evaluates to -6
\end{verbatim}

\paragraph{(ceil \emph{x})}
The smallest integral value that is not less than \emph{x}.

\begin{verbatim}
(ceil 2.3)  ; Evaluates to 3
(ceil 3.8)  ; Evaluates to 4
(ceil 5.5)  ; Evaluates to 6
(ceil -2.3) ; Evaluates to -2
(ceil -3.8) ; Evaluates to -3
(ceil -5.5) ; Evaluates to -5
\end{verbatim}

\paragraph{(trunc \emph{x})}
The nearest integral value that is not larger in magnitude than \emph{x}.

\begin{verbatim}
(trunc 2.3)  ; Evaluates to 2
(trunc 3.8)  ; Evaluates to 3
(trunc 5.5)  ; Evaluates to 5
(trunc -2.3) ; Evaluates to -2
(trunc -3.8) ; Evaluates to -3
(trunc -5.5) ; Evaluates to -5
\end{verbatim}

\paragraph{(round \emph{x})}
The integral value that is nearest to \emph{x}, with halfway cases rounded away from zero.

\begin{verbatim}
(round 2.3)  ; Evaluates to 2
(round 3.8)  ; Evaluates to 4
(round 5.5)  ; Evaluates to 6
(round -2.3) ; Evaluates to -2
(round -3.8) ; Evaluates to -4
(round -5.5) ; Evaluates to -6
\end{verbatim}

\section{Matricies}
The fundamental data structure in Likely is a four-dimensional \emph{matrix}.
In decreasing memory spatial locality order, its dimensions are: \emph{channels}, \emph{columns}, \emph{rows} and \emph{frames}.
These dimensions are often abbreviated \emph{c}, \emph{x}, \emph{y} and \emph{t}, respectively.
Ownership of matricies is managed automatically using reference counting.

\paragraph{(new [\emph{type} [\emph{channels} [\emph{columns} [\emph{rows} [\emph{frames} [\emph{data}]]]]]])}
Returns a newly allocated matrix with element type \emph{type}, dimensions \emph{channels}, \emph{columns}, \emph{rows} and \emph{frames}, initialized to \emph{data}.
If \emph{data} is not specified then the elements will be uninitialized.
If \emph{frames}, \emph{rows}, \emph{columns} or \emph{channels} are not specified then they will assume a value of \emph{1}.
If \emph{type} is not specified then it will assume a value of \emph{f32} (32-bit floating point).

\begin{verbatim}
uninitialized-color-image := (new u8 3 512 512)
\end{verbatim}

\paragraph{(channels [\emph{matrix}])}
Returns the number of channels in \emph{matrix} as a native integer.
If \emph{matrix} is not specified, returns a function which when given a matrix returns the number of channels in the matrix.

\begin{verbatim}
(channels uninitialized-color-image) ; Evaluates to 3
\end{verbatim}

\paragraph{(columns [\emph{matrix}])}
Returns the number of columns in \emph{matrix} as a native integer.
If \emph{matrix} is not specified, returns a function which when given a matrix returns the number of columns in the matrix.

\begin{verbatim}
(columns uninitialized-color-image) ; Evaluates to 512
\end{verbatim}

\paragraph{(rows [\emph{matrix}])}
Returns the number of rows in \emph{matrix} as type a native integer.
If \emph{matrix} is not specified, returns a function which when given a matrix returns the number of rows in the matrix.

\begin{verbatim}
(rows uninitialized-color-image) ; Evaluates to 512
\end{verbatim}

\paragraph{(frames [\emph{matrix}])}
Returns the number of frames in \emph{matrix} as type a native integer.
If \emph{matrix} is not specified, returns a function which when given a matrix returns the number of frames in the matrix.

\begin{verbatim}
(frames uninitialized-color-image) ; Evaluates to 1
\end{verbatim}

\section{Macros}
\paragraph{(try \emph{primary-expr} \emph{fallback-expr})}
Attempts to evaluate \emph{primary-expr} in the current environment and return the result.
Returns \emph{fallback-expr} expression in the event of an error.

\begin{verbatim}
(eval (+ 1 1) 3) ; Evaluates to 2
(eval (+ 1) 3)   ; Evaluates to 3
\end{verbatim}

\section{External Symbols}
\paragraph{(extern \emph{return-type} \emph{symbol-name} \emph{parameters})}
References an externally defined symbol.

\begin{verbatim}
((extern i32 "abs" i32) -4) ; Evaluates to 4
\end{verbatim}

\part{Standard Library}
\chapter{Basic Symbols}
\section{Constants}
\begin{likely}
null  := 0
true  := 1
false := 0
e  := (f32 2.718281)
pi := (f32 3.141592)
\end{likely}

\section{Unary Functions}
\begin{likely}
not  := (-> a (== a false))
bool := (-> a (!= a false))
sq  := (-> a (* a a))
abs := (-> a (? (< a 0) (* -1 a) a))
\end{likely}

\section{Binary Functions}
\begin{likely}
and := (-> (a b) (& a.bool b.bool))
or  := (-> (a b) (| a.bool b.bool))
xor := (-> (a b) (^ a.bool b.bool))
min := (-> (a b) (? (< a b) a b))
max := (-> (a b) (? (> a b) a b))
\end{likely}

\chapter{Library Symbols}
\section{Types}
\begin{likely}
string-t       := i8P
void-pointer-t := i8P
type-t         := u32
file-type-t    := u32
\end{likely}

\section{Matrix Information}
\begin{likely}
elements := (-> mat mat.channels :* mat.columns :* mat.rows :* mat.frames)
bytes    := (-> mat (/ (+ (* (& mat.type depth) mat.elements) 7) 8))
\end{likely}

\section{Matrix Creation}
\begin{likely}
imitate-size := (-> (mat type) (new type mat.channels mat.columns mat.rows mat.frames))
imitate := (-> mat (imitate-size mat mat.type))
\end{likely}

\section{Matrix I/O}
\begin{likely}
read   := (-> return-type (extern return-type "likely_read" (string-t file-type-t type-t)))
write  := (extern u8CXYT "likely_write" (u8CXYT string-t))
decode := (extern u8CXYT "likely_decode" (u8CXYT type-t))
encode := (extern u8CXYT "likely_encode" (u8CXYT string-t))
render := (extern u8CXYT "likely_render" (u8CXYT f64P f64P))
show   := (extern u8CXYT "likely_show" (u8CXYT string-t))
guess-file-type := (extern file-type-t "likely_guess_file_type" string-t)
\end{likely}

\begin{likely}
read-image               := (-> file-name ((read image)           file-name media     image))
read-image-grayscale     := (-> file-name ((read image-grayscale) file-name media     image-grayscale))
read-video               := (-> file-name ((read video)           file-name media     video))
read-video-grayscale     := (-> file-name ((read video-grayscale) file-name media     video-grayscale))
read-directory           := (-> file-name ((read video)           file-name directory video))
read-directory-grayscale := (-> file-name ((read video-grayscale) file-name directory video-grayscale))
\end{likely}

\section{Compiler Frontend}
\begin{likely}
lex := (extern ast "likely_lex" (string-t file-type-t))
parse := (extern ast "likely_parse" ast)
lex-and-parse := (extern ast "likely_lex_and_parse" (string-t file-type-t))
\end{likely}

\section{Compiler Backend}
\begin{likely}
eval := (extern env "likely_eval" (ast env void-pointer-t void-pointer-t))
\end{likely}

\section{Import}
\begin{likely}
import-string := (-> (source-code source-type environment) (lex-and-parse source-code source-type).(eval environment null null))
import := (-> (file environment) ((read text) file guess text).data.(import-string file.guess-file-type environment))
\end{likely}

\section{Type Conversion}
\begin{likely}
cast := (-> (a b) (b.type a)) ; convert a to the type of b
\end{likely}

\chapter{Pixel-wise operators}
\section{Thresholding}
\begin{likely}
threshold-binary          := (-> (input threshold response) (? (> input threshold) response  0))
threshold-binary-inverse  := (-> (input threshold response) (? (> input threshold) 0         response))
threshold-truncate        := (-> (input threshold)          (? (> input threshold) threshold input))
threshold-to-zero         := (-> (input threshold)          (? (> input threshold) input     0))
threshold-to-zero-inverse := (-> (input threshold)          (? (> input threshold) 0         input))
\end{likely}

\end{document}
