 % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
 % Copyright 2014 Joshua C. Klontz                                           %
 %                                                                           %
 % Licensed under the Apache License, Version 2.0 (the "License");           %
 % you may not use this file except in compliance with the License.          %
 % You may obtain a copy of the License at                                   %
 %                                                                           %
 %     http://www.apache.org/licenses/LICENSE-2.0                            %
 %                                                                           %
 % Unless required by applicable law or agreed to in writing, software       %
 % distributed under the License is distributed on an "AS IS" BASIS,         %
 % WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  %
 % See the License for the specific language governing permissions and       %
 % limitations under the License.                                            %
 % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\documentclass[twoside=false, numbers=noenddot]{scrbook}

% The Likely tokenizer will look for the use of the "likely" environment to
% determine what parts of the document are Likely source code.
\newenvironment{likely}
{ \verbatim }
{ \endverbatim }

\usepackage{booktabs}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{makeidx}
\usepackage{scrhack}
\usepackage{tocbibind}
\usepackage{verbatim}

\lstset{basicstyle=\ttfamily,
  showstringspaces=false
}

\makeindex

\newcommand{\noun}[1]{\textsc{#1}}
\newcommand{\cref}[3]{\href{#1}{#2}\cite{#3}}
\newcommand{\fref}[2]{\href{#1}{#2}\footnote{\href{#1}{#1}}}
\newcommand{\awsurl}{https://s3.amazonaws.com/liblikely/}
\newcommand{\githuburl}{https://raw.githubusercontent.com/biometrics/likely/gh-pages/}
\newcommand{\dindex}[1]{\textit{#1}\index{#1}}
\newcommand{\pindex}[1]{#1\index{#1}}
\newcommand{\tindex}[1]{\pindex{\texttt{#1}}}

% Acronyms
\newcommand{\AST}{AST\index{abstract syntax tree (AST)}}
\newcommand{\CTFE}{CTFE\index{compile-time function evaluation (CTFE)}}
\newcommand{\GFM}{GFM\index{GitHub Flavored Markdown (GFM)}}
\newcommand{\JIT}{JIT\index{just-in-time (JIT)}}
\newcommand{\LLVM}{LLVM\index{Low Level Virtual Machine (LLVM)}}

\hyphenation{Java-Script}

\title{The Likely Programming Language \\
       {\large Language Reference and Standard Library}}
\author{Joshua C. Klontz}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

\chapter{Introduction}
\fref{http://www.liblikely.org/}{\noun{Likely}} is a programming language for image processing and statistical learning algorithm development.
The following sections discuss the guiding design decisions behind Likely.

\section{Embeddable Compiler}
Likely is foremost a software library.
Both the \fref{\awsurl doxygen/console\_interpreter\_compiler.html}{\texttt{likely} console-interpreter-compiler} and the \fref{\awsurl doxygen/integrated\_development\_environment.html}{\texttt{dream} integrated development environment} are built on top of the \fref{\awsurl doxygen/index.html}{\noun{Likely C API}}.

Understandably, there is more involved in deploying a computer vision application than applying algorithms to pixels alone.
Likely is designed to excel at pixel/feature/subspace transformations, while leaving general application logic for the developer's programming language of choice.
Likely code can both call, and be called by the \cref{http://www.cs.otago.ac.nz/cosc440/readings/C-Programming-Ebook.pdf}{C Programming Language}{kernighan1988c}, and by extension many other programming languages as well.

It was with this focus on an embeddable compiler that the \url{liblikely.org} domain name was chosen.

\section{Compile-Time Function Evaluation}
Compile-time function evaluation (\CTFE) is a core tenant of the Likely programming language.
Likely rejects the learning of a statistical model as an offline step after algorithm compilation.
Instead, \emph{Likely formulates statistical learning as the compile-time evaluation of a function} (the learning algorithm) \emph{with constant arguments} (the training data).

Likely leverages the \cref{http://llvm.org/}{Low Level Virtual Machine}{lattner2004llvm} (\LLVM) project for both static and just-in-time (\JIT) compilation.
One particularly salient use of the \JIT\ compiler is for \CTFE, as the \JIT\ compiler automatically leverages all instruction set extensions and coprocessors available at runtime.
In the special case where the function to be executed does not have loops, Likely will instead run an interpreter, which has been found to be faster for executing simple code.

A computer vision algorithm is a series of image processing and statistical learning transformations requiring incoming samples that conform to particular type and dimensionality expectations.
Likely exploits these expectations through inference on the output of functions evaluated at compile time.
Algorithms written without specifying parameter types are still statically compiled because \emph{\CTFE\ output dictates parameter type, and often array dimensionality as well}.
This is in contrast to conventional computer vision libraries which, lacking compile-time knowledge of the particular algorithm of interest, provide parameter type generality by branching at runtime.
This branching is often unnecessary for any particular algorithm where all runtime samples are expected to follow the same code path.

\section{Portability}
Likely is written in a portable subset of modern C++\cite{stroustrup1986c++}, which means it can \fref{http://llvm.org/docs/GettingStarted.html\#hardware}{run everywhere \LLVM\ does}.
Algorithms execute natively on single CPU threads via the \LLVM\ \noun{Machine Code \JIT} compiler, multi-core CPUs via a custom \noun{OpenMP}-like backend, and GPUs and coprocessors via \noun{CUDA} or \noun{OpenCL} (in progress).

Likely algorithms can be \fref{http://liblikely.org/share/likely/hello\_world/hello\_world\_static.c}{statically compiled to native object files}, \fref{http://liblikely.org/share/likely/hello\_world/hello\_world\_jit.c}{just-in-time compiled for dynamic applications and scripts}, integrated into other languages (in progress), published as web services (in progress), and even transcompiled into single \noun{C} or \noun{JavaScript} source files (in progress).

\section{Live Coding}
Developing computer vision algorithms is a creative process, and like all creative processes it relies on immediate visceral feedback through interaction with the creative medium.
Algorithms have numerous parameters, and visualizing their effects is critical to building intuition and making improvements.
The computer vision domain and Likely's library design are well suited for the idea of \dindex{live coding} popularized by \fref{http://worrydream.com/}{Bret Victor}.
In fact, Likely's accompanying IDE called \emph{dream}, is \fref{https://www.youtube.com/watch?v=a\_hz8wFACVM}{designed from the ground up to support interactive algorithm development}.

\section{Literate Programming}
Likely is a \cref{http://www.literateprogramming.com/}{\pindex{literate programming}}{knuth1984literate} language.
In addition to serving as the reference manual for the programming language and standard library, \fref{\githuburl library/standard.tex}{\emph{this document is also the source code for the Likely standard library}}.

Likely recognizes both \fref{https://help.github.com/articles/github-flavored-markdown}{GitHub Flavored Markdown} (\GFM) and \cref{http://www.latex-project.org/}{\LaTeX \index{LaTeX}}{lamport1986document} syntax, and will automatically extract source code from appropriately marked blocks.

\part{Language Reference}
\chapter{Parsing}
This chapter covers how a source code file is translated into the compiler's \emph{abstract syntax tree} (\AST) program representation.
This is also referred to as the compiler's \fref{\awsurl doxygen/group\_\_frontend.html}{\dindex{frontend}}.

\section{Source Code File Formats}
To facilitate \pindex{literate programming}, Likely recognizes several source code file formats based on their extension:

\begin{figure}[h]
\begin{description}
\item[.lisp] - The entire file is Likely source code.
\item[.md]   - \GFM\ file, source code is extracted from \texttt{likely} syntax-highlighted code blocks.
\item[.tex]  - \pindex{LaTeX} file, source code is extracted from the \texttt{likely} environment.
\end{description}
\caption{Source code file extensions and formats.}
\end{figure}

For example, this \GFM\ \fref{\githuburl library/literate\_programming.md}{source file} can be rendered \fref{http://liblikely.org/?href=literate\_programming}{in a web browser} and also executed by Likely:

\begin{lstlisting}[language=bash, caption={Literate programming using \GFM.}, captionpos=b]
$ likely library/literate_programming.md
42
\end{lstlisting}

Similarly, this \pindex{LaTeX} \fref{\githuburl library/literate\_programming.tex}{source file} can be rendered \fref{\awsurl latex/literate\_programming.pdf}{to \noun{PDF}} and also executed by Likely:

\begin{lstlisting}[language=bash, caption={Literate programming using \pindex{LaTeX}.}, captionpos=b]
$ likely library/literate_programming.tex
42
\end{lstlisting}

\tindex{likely\char`_guess\char`_file\char`_type} is the function call for inferring file format from extension.

\section{Lexical Analysis}
Source code is first converted into a sequence of words or \dindex{tokens} by applying the following rules:

\begin{figure}[h]
\begin{enumerate}
\item Tokens are separated by \pindex{whitespace}.
\item The following special single-character tokens need not be separated by \pindex{whitespace}:\newline
      \texttt{();.:}
\item The characters between double-quotation marks are a single token, including the quotation marks themselves.
\end{enumerate}
\caption{Lexical analysis rules.}
\end{figure}

Where \dindex{whitespace} is defined by the C function \fref{http://www.cplusplus.com/reference/cctype/isspace/}{\texttt{isspace}}.

\tindex{likely\char`_lex} is the function call for lexical analysis.

\section{Prefix Notation}
Likely is a member of the Lisp family of languages, accepting fully-parenthesized Polish \pindex{prefix notation}:

\begin{figure}[h]
\centering
\texttt{($operator$ $operand_1$ $operand_2$ \dots\ $operand_N$)}
\caption{Prefix notation.}
\end{figure}

For example:

\begin{lstlisting}[language=bash, caption={Prefix notation example.}, captionpos=b]
$ likely -c "(+ 1 2)"
3
\end{lstlisting}

An important property of prefix notation is that it is equivalent to the \AST, where a branch is a \dindex{list} and leaf is an \dindex{atom}.
Every branch or leaf is also called an \dindex{expression}.
A reading of \cref{https://mitpress.mit.edu/sicp/full-text/book/book.html}{Structure and Interpretation of Computer Programs}{Abelson:1996:SIC:547755} is strongly encouraged for developers interested in a deeper understanding of the motivations behind this syntax.

\tindex{likely\char`_parse} is the function call for constructing an \AST\ from \pindex{tokens}.

\section{Special Tokens}
Likely recognizes three special \pindex{tokens} that influence how \pindex{expressions} are parsed into an \AST.
These \pindex{tokens} allow developers to selectively depart from \pindex{prefix notation} to improve code readability.

\begin{table}[h]
\centering
\begin{tabular}{@{} l l @{}}
\toprule
Token & Name    \\ \midrule
;     & Comment \\
.     & Compose \\
:     & Infix   \\
\bottomrule
\end{tabular}
\caption{Likely special tokens.}
\end{table}

When in doubt, you can print the \AST\ to see how source code is parsed:
\begin{lstlisting}[language=bash, caption={Printing the abstract syntax tree.}, captionpos=b]
$ likely -ast -c "1 :+ 2"
(+ 1 2)
\end{lstlisting}

\subsection{; (Comment)}
The semicolon and all subsequent \pindex{tokens} through the end of the line are excluded from the \AST.

\begin{verbatim}
(this is some code) ; this is a comment
; (also a comment)
(back to code again)
\end{verbatim}

\subsection{. (Compose)}
The \pindex{expression} to the left-hand-side (LHS) of the period is the first operand of the expression to the right-hand-side (RHS) of the period.
Compose \index{compose} is \emph{left-associative}.

\begin{verbatim}
x.f     ; Parsed as (f x)
x.f.g   ; Parsed as (g (f x))
x.(f y) ; Parsed as (f x y)
(f x).g ; Parsed as (g (f x))
(g x.f) ; Parsed as (g (f x))
7.2     ; Parsed as 7.2
3.sq    ; Evaluates to 9
1.(+ 2) ; Evaluates to 3
\end{verbatim}

We might call the third example \cref{http://www.drdobbs.com/cpp/uniform-function-call-syntax/232700394}{uniform function call syntax}{Bright:2012:UFC}.
In the sixth example, note how this transformation does not apply to numbers!

\subsection{: (Infix)}
The \pindex{expression} to the RHS of the colon is the operator.
The \pindex{expression} to the LHS of the colon is the first operand.
The second \pindex{expression} to the RHS of the colon is the second operand.
Infix \index{infix} is \emph{right-associative} and has \emph{lower} precedence than \pindex{compose}.

\begin{verbatim}
x:f y       ; Parsed as (f x y)
z:g x:f y   ; Parsed as (g z (f x y))
x:f (g y)   ; Parsed as (f x (g y))
x.f:h y.g   ; Parsed as (h (f x) (g y))
(g x:f y)   ; Parsed as (g (f x y))
1:+ 2       ; Evaluates to 3
3.sq:+ 4.sq ; Evaluates to 25
\end{verbatim}

\chapter{Literals}
The Likely compiler recognizes the following kinds of fixed, or \dindex{literal}, \pindex{atom}s.

\section{Integer}
An \dindex{integer} is an \pindex{atom} that can be parsed \emph{to completion in base-10} by the C function \fref{http://www.cplusplus.com/reference/cstdlib/strtoll/}{\texttt{strtoll}}.
If the value can be represented without loss as an \texttt{int32\_t} then it is done so, otherwise it is represented as an \texttt{int64\_t}.

\begin{verbatim}
-42 ; An integer
42a ; Not an integer
\end{verbatim}

\section{Real}
A \dindex{real} is an \pindex{atom} that can be parsed \emph{to completion} by the C function \fref{http://www.cplusplus.com/reference/cstdlib/strtod/}{\texttt{strtod}}.
If the value can be represented without loss as a \texttt{float} then it is done so, otherwise it is represented as a \texttt{double}.

\begin{verbatim}
0.42  ; A real
0.42- ; Not a real
\end{verbatim}

\section{String}
A \dindex{string} is an \pindex{atom} enclosed in double-quotation marks.
Values are represented as \texttt{const char*}.

\begin{verbatim}
"hello world" ; A string
'hello world' ; Not a string
\end{verbatim}

\section{Type}
A \dindex{type} is a keyword indicating how data is represented.
Let's start with a few examples:

\begin{verbatim}
i16  ; 16-bit signed integer scalar
u32  ; 32-bit unsigned integer scalar
f64  ; 64-bit floating-point real scalar
f32C ; 32-bit floating-point real multi-channel vector
u8XY ; 8-bit unsigned integer multi-column multi-row matrix
\end{verbatim}

In general, a \pindex{type} conforms to the following regular expression:

\begin{figure}[h]
\centering
\texttt{[uif]\textbackslash d+P?S?C?X?Y?T?}
\caption{Regular expression for identifying types.}
\end{figure}

The first character indicates the element bit pattern, and is one of:

\begin{figure}[h]
\begin{description}
\item[u] - Unsigned integer
\item[i] - Signed integer
\item[f] - Floating-point real
\end{description}
\caption{Type leading character.}
\end{figure}

The next one-or-more decimal characters indicate the element bit depth, and should generally be a power of two.
The remaining capitalized characters indicate:

\begin{figure}[h]
\begin{description}
\item[P] - Type is a pointer
\item[S] - Perform saturated arithmetic
\item[C] - Multi-channel matrix
\item[X] - Multi-column matrix
\item[Y] - Multi-row matrix
\item[T] - Multi-frame matrix
\end{description}
\caption{Type trailing characters.}
\end{figure}

The presence or absense of \texttt{C}, \texttt{X}, \texttt{Y} and \texttt{T} indicate whether we call it a \dindex{scalar}, \dindex{vector} or \dindex{matrix} \pindex{type}.

\tindex{likely\char`_type\char`_from\char`_string} is the formal definition of a \pindex{type}.
In addition to accepting the general pattern mentioned above, this function also recognizes a number of special cases corresponding to values in \tindex{likely\char`_type\char`_mask}.
The special cases include all common C types.

\chapter{Intrinsic Operators}
An intrinsic operator is the basic construct for higher order expressions on numbers, strings and types.
Likely has the following builtin operators.

\section{Arithmetic}
\paragraph{(+ \emph{lhs} \emph{rhs})}
The addition of \emph{lhs} by \emph{rhs}.

\begin{verbatim}
(+ 2 2)     ; Evaluates to 4
(+ 1.8 2)   ; Evaluates to 3.8
(+ 1.8 2.1) ; Evaluates to 3.9
(+ 1.8 2.2) ; Evaluates to 4
\end{verbatim}

\paragraph{(- \emph{lhs} [\emph{rhs}])}
The subtraction of \emph{lhs} by \emph{rhs}.
If \emph{rhs} is not provided then the negation of \emph{lhs}.

\begin{verbatim}
(- 3 2)     ; Evaluates to 1
(- 2 3)     ; Evaluates to -1
(- 3.2 2)   ; Evaluates to 1.2
(- 3.2 2.1) ; Evaluates to 1.1
(- 3.2 2.2) ; Evaluates to 1
(- 1)       ; Evaluates to -1
(- -1.1)    ; Evaluates to 1.1
\end{verbatim}

\paragraph{(* \emph{lhs} \emph{rhs})}
The multiplication of \emph{lhs} by \emph{rhs}.

\begin{verbatim}
(* 1 2)     ; Evaluates to 2
(* 1.3 2)   ; Evaluates to 2.6
(* 1.4 2.1) ; Evaluates to 2.94
(* 1.5 2.0) ; Evaluates to 3
\end{verbatim}

\paragraph{(/ \emph{lhs} \emph{rhs})}
The division of \emph{lhs} by \emph{rhs}.

\begin{verbatim}
(/ 4 2)     ; Evaluates to 2
(/ 4.5 2)   ; Evaluates to 2.25
(/ 4.5 2.5) ; Evaluates to 1.8
(/ 4.2 2.1) ; Evaluates to 2
\end{verbatim}

\paragraph{(\% \emph{lhs} \emph{rhs})}
The remainder after division of \emph{lhs} by \emph{rhs}.

\begin{verbatim}
(% 7 3)      ; Evaluates to 1
(% 6 3)      ; Evaluates to 0
(% 6.5 3)    ; Evaluates to 0.5
(% -6.5 3)   ; Evaluates to -0.5
(% 6.5 -3)   ; Evaluates to 0.5
(% -6.5 -3)  ; Evaluates to -0.5
(% 6.5 7.5)  ; Evaluates to 6.5
(% 6.5 3.25) ; Evaluates to 0
\end{verbatim}

\section{Comparison}
\paragraph{(== \emph{lhs} \emph{rhs})}
One if \emph{lhs} equals \emph{rhs}, zero otherwise.

\begin{verbatim}
(== 2 2)   ; Evaluates to 1
(== 2 2.0) ; Evaluates to 1
(== 2 -2)  ; Evaluates to 0
(== 2 2.1) ; Evaluates to 0
\end{verbatim}

\paragraph{(!= \emph{lhs} \emph{rhs})}
One if \emph{lhs} does not equal \emph{rhs}, zero otherwise.

\begin{verbatim}
(!= 3 3)   ; Evaluates to 0
(!= 3 3.0) ; Evaluates to 0
(!= 3 -3)  ; Evaluates to 1
(!= 3 3.1) ; Evaluates to 1
\end{verbatim}

\paragraph{(< \emph{lhs} \emph{rhs})}
One if \emph{lhs} is less than \emph{rhs}, zero otherwise.

\begin{verbatim}
(< 4 5)    ; Evaluates to 1
(< 4 -5.0) ; Evaluates to 0
(< 4 4.0)  ; Evaluates to 0
\end{verbatim}

\paragraph{(<= \emph{lhs} \emph{rhs})}
One if \emph{lhs} is less than or equal to \emph{rhs}, zero otherwise.

\begin{verbatim}
(<= 4 5)    ; Evaluates to 1
(<= 4 -5.0) ; Evaluates to 0
(<= 4 4.0)  ; Evaluates to 1
\end{verbatim}

\paragraph{(> \emph{lhs} \emph{rhs})}
One if \emph{lhs} is greater than \emph{rhs}, zero otherwise.

\begin{verbatim}
(> 6 7)    ; Evaluates to 0
(> 6 -7.0) ; Evaluates to 1
(> 6 6.0)  ; Evaluates to 0
\end{verbatim}

\paragraph{(>= \emph{lhs} \emph{rhs})}
One if \emph{lhs} is greater than or equal to \emph{rhs}, zero otherwise.

\begin{verbatim}
(>= 6 7)    ; Evaluates to 0
(>= 6 -7.0) ; Evaluates to 1
(>= 6 6.0)  ; Evaluates to 1
\end{verbatim}

\section{Bit Manipulation}
\paragraph{(\& \emph{lhs} \emph{rhs})}
Bitwise and of \emph{lhs} and \emph{rhs}.

\begin{verbatim}
(& 1 2) ; Evaluates to 0
(& 1 3) ; Evaluates to 1
\end{verbatim}

\paragraph{(| \emph{lhs} \emph{rhs})}
Bitwise or of \emph{lhs} and \emph{rhs}.

\begin{verbatim}
(| 1 2) ; Evaluates to 3
(| 1 3) ; Evaluates to 3
\end{verbatim}

\paragraph{(\^{} \emph{lhs} \emph{rhs})}
Bitwise exclusive or of \emph{lhs} and \emph{rhs}.

\begin{verbatim}
(^ 1 2) ; Evaluates to 3
(^ 1 3) ; Evaluates to 2
\end{verbatim}

\paragraph{(<< \emph{lhs} \emph{rhs})}
Left shift of \emph{lhs} by \emph{rhs} bits.

\begin{verbatim}
(<< 2 0) ; Evaluates to 2
(<< 2 1) ; Evaluates to 4
\end{verbatim}

\paragraph{(>> \emph{lhs} \emph{rhs})}
Right shift of \emph{lhs} by \emph{rhs} bits.
Arithmetic right shift (sign extension) if \emph{lhs} is signed, logical right shift (zero extension) otherwise.

\begin{verbatim}
(>> 2 0)  ; Evaluates to 2
(>> 2 1)  ; Evaluates to 1
(>> 2 2)  ; Evaluates to 0
(>> -2 0) ; Evaluates to -2
(>> -2 1) ; Evaluates to -1
\end{verbatim}

\section{Math}
\paragraph{(sqrt \emph{x})}
The square root of \emph{x}.

\begin{verbatim}
(sqrt 2)   ; Evaluates to 1.41421
(sqrt 2.1) ; Evaluates to 1.44914
(sqrt 4)   ; Evaluates to 2
(sqrt 0)   ; Evaluates to 0
\end{verbatim}

\paragraph{(sin \emph{x})}
The sine of an angle of \emph{x} radians.

\begin{verbatim}
(sin 0)         ; Evaluates to 0
(sin 1.570796)  ; Evaluates to 1
(sin -1.570796) ; Evaluates to -1
(sin 0.523599)  ; Evaluates to 0.5
\end{verbatim}

\paragraph{(cos \emph{x})}
The cosine of an angle of \emph{x} radians.

\begin{verbatim}
(cos 0)        ; Evaluates to 1
(cos 3.141593) ; Evaluates to -1
(cos 1.047198) ; Evaluates to 0.5
\end{verbatim}

\paragraph{(pow \emph{base} \emph{exponent})}
The \emph{base} raised to the power \emph{exponent}.

\begin{verbatim}
(pow 2 3)     ; Evaluates to 8
(pow 2 -3)    ; Evaluates to 0.125
(pow -2 3)    ; Evaluates to -8
(pow 1.5 0.5) ; Evaluates to 1.22474
(pow 2 0.5)   ; Evaluates to 1.41421
(pow 4 0.5)   ; Evaluates to 2
(pow 4 0)     ; Evaluates to 1
\end{verbatim}

\paragraph{(exp \emph{x})}
The base-e exponential function of \emph{x}, which is e raised to the power \emph{x}.

\begin{verbatim}
(exp 0)   ; Evaluates to 1
(exp 1)   ; Evaluates to 2.71828
(exp 1.5) ; Evaluates to 4.48169
\end{verbatim}

\paragraph{(exp2 \emph{x})}
The base-2 exponential function of \emph{x}, which is 2 raised to the power \emph{x}.

\begin{verbatim}
(exp2 0)   ; Evaluates to 1
(exp2 1)   ; Evaluates to 2
(exp2 0.5) ; Evaluates to 1.41421
(exp2 3)   ; Evaluates to 8
\end{verbatim}

\paragraph{(log \emph{x})}
The natural logarithm of \emph{x}.

\begin{verbatim}
(log 1)        ; Evaluates to 0
(log 2.718281) ; Evaluates to 1
(log 7.389056) ; Evaluates to 2
(log 0.5)      ; Evaluates to -0.693147
\end{verbatim}

\paragraph{(log10 \emph{x})}
The common (base-10) logarithm of \emph{x}.

\begin{verbatim}
(log10 1)   ; Evaluates to 0
(log10 10)  ; Evaluates to 1
(log10 100) ; Evaluates to 2
(log10 0.5) ; Evaluates to -0.30103
\end{verbatim}

\paragraph{(log2 \emph{x})}
The binary (base-2) logarithm of \emph{x}.

\begin{verbatim}
(log2 1)   ; Evaluates to 0
(log2 2)   ; Evaluates to 1
(log2 4)   ; Evaluates to 2
(log2 0.5) ; Evaluates to -1
(log2 10)  ; Evaluates to 3.32193
\end{verbatim}

\paragraph{(copysign \emph{x} \emph{y})}
A value with the magnitude of \emph{x} and the sign of \emph{y}.

\begin{verbatim}
(copysign 3 -1.1) ; Evaluates to -3
(copysign -4.3 2) ; Evaluates to 4.3
\end{verbatim}

\paragraph{(floor \emph{x})}
The largest integral value that is not greater than \emph{x}.

\begin{verbatim}
(floor 2.3)  ; Evaluates to 2
(floor 3.8)  ; Evaluates to 3
(floor 5.5)  ; Evaluates to 5
(floor -2.3) ; Evaluates to -3
(floor -3.8) ; Evaluates to -4
(floor -5.5) ; Evaluates to -6
\end{verbatim}

\paragraph{(ceil \emph{x})}
The smallest integral value that is not less than \emph{x}.

\begin{verbatim}
(ceil 2.3)  ; Evaluates to 3
(ceil 3.8)  ; Evaluates to 4
(ceil 5.5)  ; Evaluates to 6
(ceil -2.3) ; Evaluates to -2
(ceil -3.8) ; Evaluates to -3
(ceil -5.5) ; Evaluates to -5
\end{verbatim}

\paragraph{(trunc \emph{x})}
The nearest integral value that is not larger in magnitude than \emph{x}.

\begin{verbatim}
(trunc 2.3)  ; Evaluates to 2
(trunc 3.8)  ; Evaluates to 3
(trunc 5.5)  ; Evaluates to 5
(trunc -2.3) ; Evaluates to -2
(trunc -3.8) ; Evaluates to -3
(trunc -5.5) ; Evaluates to -5
\end{verbatim}

\paragraph{(round \emph{x})}
The integral value that is nearest to \emph{x}, with halfway cases rounded away from zero.

\begin{verbatim}
(round 2.3)  ; Evaluates to 2
(round 3.8)  ; Evaluates to 4
(round 5.5)  ; Evaluates to 6
(round -2.3) ; Evaluates to -2
(round -3.8) ; Evaluates to -4
(round -5.5) ; Evaluates to -6
\end{verbatim}

\section{Matricies}
The fundamental data structure in Likely is a four-dimensional \emph{matrix}.
In decreasing memory spatial locality order, its dimensions are: \emph{channels}, \emph{columns}, \emph{rows} and \emph{frames}.
These dimensions are often abbreviated \emph{c}, \emph{x}, \emph{y} and \emph{t}, respectively.
Ownership of matricies is managed automatically using reference counting.

\paragraph{(new [\emph{type} [\emph{channels} [\emph{columns} [\emph{rows} [\emph{frames} [\emph{data}]]]]]])}
Returns a newly allocated matrix with element type \emph{type}, dimensions \emph{channels}, \emph{columns}, \emph{rows} and \emph{frames}, initialized to \emph{data}.
If \emph{data} is not specified then the elements will be uninitialized.
If \emph{frames}, \emph{rows}, \emph{columns} or \emph{channels} are not specified then they will assume a value of \emph{1}.
If \emph{type} is not specified then it will assume a value of \emph{f32} (32-bit floating point).

\begin{verbatim}
uninitialized-color-image := (new u8CXY 3 512 512 1 null)
\end{verbatim}

\paragraph{(channels [\emph{matrix}])}
Returns the number of channels in \emph{matrix} as a native integer.
If \emph{matrix} is not specified, returns a function which when given a matrix returns the number of channels in the matrix.

\begin{verbatim}
(channels uninitialized-color-image) ; Evaluates to 3
\end{verbatim}

\paragraph{(columns [\emph{matrix}])}
Returns the number of columns in \emph{matrix} as a native integer.
If \emph{matrix} is not specified, returns a function which when given a matrix returns the number of columns in the matrix.

\begin{verbatim}
(columns uninitialized-color-image) ; Evaluates to 512
\end{verbatim}

\paragraph{(rows [\emph{matrix}])}
Returns the number of rows in \emph{matrix} as type a native integer.
If \emph{matrix} is not specified, returns a function which when given a matrix returns the number of rows in the matrix.

\begin{verbatim}
(rows uninitialized-color-image) ; Evaluates to 512
\end{verbatim}

\paragraph{(frames [\emph{matrix}])}
Returns the number of frames in \emph{matrix} as type a native integer.
If \emph{matrix} is not specified, returns a function which when given a matrix returns the number of frames in the matrix.

\begin{verbatim}
(frames uninitialized-color-image) ; Evaluates to 1
\end{verbatim}

\section{Macros}
\paragraph{(try \emph{primary-expr} \emph{fallback-expr})}
Attempts to evaluate \emph{primary-expr} in the current environment and return the result.
Returns \emph{fallback-expr} expression in the event of an error.

\begin{verbatim}
(eval (+ 1 1) 3) ; Evaluates to 2
(eval (+ 1) 3)   ; Evaluates to 3
\end{verbatim}

\section{External Symbols}
\paragraph{(extern \emph{return-type} \emph{symbol-name} \emph{parameters})}
References an externally defined symbol.

\begin{verbatim}
((extern i32 "abs" i32) -4) ; Evaluates to 4
\end{verbatim}

\part{Standard Library}
\chapter{Basic Symbols}
\section{Constants}
\begin{likely}
null  := 0
true  := 1
false := 0
e  := (f32 2.718281)
pi := (f32 3.141592)
\end{likely}

\section{Numeric Limits}
\begin{likely}
numeric-limit-max := (-> t (numeric-limit t 1))
numeric-limit-min := (-> t (numeric-limit t 0))
\end{likely}

\section{Unary Functions}
\begin{likely}
not  := (-> a (== a false))
bool := (-> a (!= a false))
sq  := (-> a (* a a))
abs := (-> a (? (< a 0) (* -1 a) a))
\end{likely}

\section{Binary Functions}
\begin{likely}
and := (-> (a b) (& a.bool b.bool))
or  := (-> (a b) (| a.bool b.bool))
xor := (-> (a b) (^ a.bool b.bool))
min := (-> (a b) (? (< a b) a b))
max := (-> (a b) (? (> a b) a b))
\end{likely}

\chapter{Library Symbols}
\section{Types}
\begin{likely}
string-t       := i8P
void-pointer-t := i8P
type-t         := u32
file-type-t    := u32
\end{likely}

\section{Matrix Information}
\begin{likely}
elements := (-> mat mat.channels :* mat.columns :* mat.rows :* mat.frames)
bytes    := (-> mat (/ (+ (* (& mat.type depth) mat.elements) 7) 8))
\end{likely}

\section{Matrix Creation}
\begin{likely}
new := (-> (return-type channels columns rows frames data)
           ((extern return-type "likely_new" (type-t u32 u32 u32 u32 void-pointer-t)) return-type channels columns rows frames data))
imitate-size := (-> (mat type) (new type mat.channels mat.columns mat.rows mat.frames null))
imitate := (-> mat (imitate-size mat mat.type))
\end{likely}

\section{Matrix I/O}
\begin{likely}
read   := (-> (file-name file-type return-type)
              ((extern return-type "likely_read" (string-t file-type-t type-t)) file-name file-type return-type))
write  := (extern u8CXYT "likely_write" (u8CXYT string-t))
decode := (-> (mat return-type)
              ((extern return-type "likely_decode" (u8CXYT type-t)) mat return-type))
encode := (extern u8CXYT "likely_encode" (u8CXYT string-t))
render := (extern u8CXYT "likely_render" (u8CXYT f64P f64P))
show   := (extern u8CXYT "likely_show" (u8CXYT string-t))
guess-file-type := (extern file-type-t "likely_guess_file_type" string-t)
\end{likely}

\begin{likely}
read-image               := (-> file-name file-name.(read media     image          ))
read-image-grayscale     := (-> file-name file-name.(read media     image-grayscale))
read-video               := (-> file-name file-name.(read media     video          ))
read-video-grayscale     := (-> file-name file-name.(read media     video-grayscale))
read-directory           := (-> file-name file-name.(read directory video          ))
read-directory-grayscale := (-> file-name file-name.(read directory video-grayscale))
\end{likely}

\section{Compiler Frontend}
\begin{likely}
lex := (extern ast "likely_lex" (string-t file-type-t))
parse := (extern ast "likely_parse" ast)
lex-and-parse := (extern ast "likely_lex_and_parse" (string-t file-type-t))
\end{likely}

\section{Compiler Backend}
\begin{likely}
eval := (extern env "likely_eval" (ast env void-pointer-t void-pointer-t))
\end{likely}

\section{Import}
\begin{likely}
import-string := (-> (source-code source-type environment) (lex-and-parse source-code source-type).(eval environment null null))
import := (-> (file-name environment) file-name.(read guess text).data.(import-string file-name.guess-file-type environment))
\end{likely}

\section{Type Conversion}
\begin{likely}
cast := (-> (a b) (b.type a)) ; convert a to the type of b
depth-double := (-> t (| (* (& t depth) 2) (& t (~ depth))).make-type)
depth-atleast := (-> (t bits) (| (max bits (& t depth)) (& t (~ depth))).make-type)
depth-atleast-16 := (-> t (depth-atleast t 16))
depth-atleast-32 := (-> t (depth-atleast t 32))
depth-atleast-64 := (-> t (depth-atleast t 64))

single-dimension := (-> d (-> t (& t (~ d))))
single-channel := (single-dimension multi-channel)
single-column  := (single-dimension multi-column )
single-row     := (single-dimension multi-row    )
single-frame   := (single-dimension multi-frame  )

imitate-dimension := (-> d (-> (t u) (? (& u d) (| t d) (& t (~ d)))))
imitate-channel := (imitate-dimension multi-channel)
imitate-column  := (imitate-dimension multi-column)
imitate-row     := (imitate-dimension multi-row)
imitate-frame   := (imitate-dimension multi-frame)
\end{likely}

\chapter{Pixel-wise operators}
\section{Thresholding}
\begin{likely}
threshold-binary          := (-> (input threshold response) (? (> input threshold) response  0))
threshold-binary-inverse  := (-> (input threshold response) (? (> input threshold) 0         response))
threshold-truncate        := (-> (input threshold)          (? (> input threshold) threshold input))
threshold-to-zero         := (-> (input threshold)          (? (> input threshold) input     0))
threshold-to-zero-inverse := (-> (input threshold)          (? (> input threshold) 0         input))
\end{likely}

\chapter{Loops}
\section{iter}
\begin{likely}
iter :=
  (expr end) :->
  {
    i :<- 0
  loop.#
    (!= i end) :? {
      (expr i)
      i :<- (+ i 1)
      loop
    }
  }
\end{likely}

\chapter{Reductions}
\section{Average}
\begin{likely}
average-frame :=
  mat :->
  {
    result := (new mat.type.single-frame mat.channels mat.columns mat.rows 1 null)
    len := mat.frames
    (result mat len) :=>
    {
      j :<- (mat.type.depth-double.depth-atleast-32 0)
      (-> t (<- j (+ j (mat c x y t)))).(iter len)
      result :<- (result.type (/ j len))
    }
  }

center-frame :=
  mat :->
  {
    avg := mat.average-frame
    result := mat.(imitate-size mat.type.depth-double.signed)
    (result mat avg) :=> (<- result (- (result.type mat) (result.type avg)))
  }
\end{likely}

\chapter{Convolutions}
\section{Covariance}
\begin{likely}
covariance :=
  vecs :->
    {
        cov := (new vecs.type.floating vecs.channels vecs.columns vecs.columns vecs.frames null)
        ; TODO - complete
        cov
    }
\end{likely}

\bibliographystyle{plain}
\bibliography{library/standard}

\printindex

\end{document}
