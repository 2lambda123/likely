Likely
======

 > An image recognition runtime for heterogenous architectures.
 > -- [@jklontz](https://github.com/jklontz)

## Introduction
Welcome to the documentation and source code for _Likely_, the image recognition programming language!

**Skip to the good stuff: [tutorial](?show=tutorial), [demos](?show=demos), [benchmark](?show=benchmark.tsv).**

### Principles
 - Heterogeneous hardware architecture support
 - Efficient syntax for feature representation and statistical learning
 - Immediate visual feedback during algorithm development
 - Embeddable into other projects and languages
 - Free open source software

### Help
We try to keep this document complete and correct. However, should you run into trouble, please feel free to ask questions on our [mailing list](https://groups.google.com/forum/#!forum/likely-dev) or report bugs on our [issue tracker](https://github.com/biometrics/likely/issues). Consider starting with **hello world in [Likely](?show=hello_world) and [C](?show=share/likely/hello_world/README.md)**.

#### This Document
**Likely is a [literate programming](http://en.wikipedia.org/wiki/Literate_programming) language.** In addition to documenting the project, this file is also the [source code](library/standard.like) for the standard library. Likely uses [Github Flavored Markdown](https://help.github.com/articles/github-flavored-markdown) (GFM) syntax, and the Likely runtime will automatically extract and execute _code blocks_ found in GFM source files.

#### License
Likely is licensed under [Apache 2.0](LICENSE.txt), meaning it is *free for academic and commercial use*.

### Background
The software engineering of a complex system is often facilitated by a _Domain Specific Language_ (DSL) whose syntax is designed to concisely and efficiently solve problems frequently encountered in the domain. While many technical communities rely on DSLs, there currently exists no DSL designed for image recognition. As a consequence, most libraries and applications are written in either [_C++_ or _MATLAB_](?show=motivation), neither of which respect both the engineer's time and the hardware's compute capability.

> A just-in-time compiled DSL for image recognition is essential to express algorithms that are currently too complex to implement in native languages and too inefficient to execute in scripting languages.

### Portability
Likely is built on top of the _Low Level Virtual Machine_ (LLVM) compiler infrastructure using a portable subset of ISO C++11, which means it runs [everywhere](http://llvm.org/docs/GettingStarted.html#hardware) LLVM does. Algorithms execute natively on single CPU threads via the LLVM _Machine Code Just-In-Time_ (MCJIT) compiler, multi-core CPUs via a custom _OpenMP_-like backend, and GPUs and coprocessors via _CUDA_ or _OpenCL_.

| Backend     | Status |
|-------------|--------|
| Single-core | Done   |
| Multi-core  | Done   |
| CUDA        | [#24](https://github.com/biometrics/likely/issues/24) |
| OpenCL      | [#25](https://github.com/biometrics/likely/issues/25) |

### Speed
Likely relies on the powerful and well established LLVM compiler infrastructure to make function execution as fast as possible. Since compilation is held off until runtime, functions automatically leverage all instruction set extensions and co-processors available on the host. Delaying compilation until runtime also enables optimization opportunities that are impossible in conventional languages and libraries. In fact, the entire premise of Likely is hinged on the observation that for image processing applications

> while funtions must be written generically to handle any matrix type, at runtime they tend to be executed repeatedly on the same type.

The repeated execution of a function with the same matrix type means that branching to handle different data types is unnecessary, entire loops and code blocks can be eliminated, and many values that would be runtime parameters can instead become compile time constants. For these reasons, we expect Likely to be faster than equally-generic statically-compiled native code.

## C API
C/C++ projects should **#include <likely.h>** and link against the **likely** library. **LikelyConfig.cmake** is provided in **share/likely/** as a convenience to CMake developers. Likely definitions are prefixed with **likely_** and use a **lowercase_underscore** naming convention. Consider taking a moment to skim the [header file](include/likely.h).

### The Matrix Struct
The **likely_mat**, or _matrix_, is only struct in the API and serves as the input and output for all function invocations:

| Field    | Type           | Description                       |
|----------|----------------|-----------------------------------|
| data     | likely_data    | Pointer to the buffer of elements |
| d_ptr    | likely_private | Used for internal bookkeeping     |
| channels | likely_size    | Matrix dimension                  |
| columns  | likely_size    | Matrix dimension                  |
| rows     | likely_size    | Matrix dimension                  |
| frames   | likely_size    | Matrix dimension                  |
| type     | likely_type    | Matrix type                       |

The last five fields (_channels_, _columns_, _rows_, _frames_, and _type_) are collectively referred to as the matrix _header_. In contrast to most image processing libraries which tend to feature 3-dimensional matrices (channels, columns, rows), Likely includes a fourth dimension, frames, in order to facilitate processing videos or collections of images.

#### Element Access
By convention, element layout in the data buffer with resepect to decreasing spatial locality is _channel_, _column_, _row_, _frame_. Thus an element at channel _c_, column _x_, row _y_, and frame _t_, can be retrieved like:
```C++
float likely_get_element(likely_mat m, likely_size c, likely_size x, likely_size y, likely_size t)
{
    likely_size columnStep = m->channels;
    likely_size rowStep = m->channels * columnStep;
    likely_size frameStep = m->rows * rowStep;
    likely_size index = t*frameStep + y*rowStep + x*columnStep + c;
    assert(likely_type(m) == likely_type_f32);
    return reinterpret_cast<float*>(m->data)[index];
}
```

Convenience functions **likely_element** and **likely_set_element** are provided for individual element access. These functions are inefficient for iterating over a large numbers of elements due to the repeated index calculations, and their use is suggested only for debugging purposes or when the matrix is known to be small.

#### Matrix Type
As suggested earlier, **likely_type** plays a critical role in determining how to process matricies. The type is a 4-byte _bit field_ that encodes what data type the matrix is and how/where it should be processed. It also specifies knowledge used to optimized code generation and by removing unneccesary indexing, looping, and branching.

Here is the layout of the bits in **likey_type**:

| Field         | Bits | Mask       |
|---------------|------|------------|
| depth         | 8    | 0x000000FF |
| signed        | 1    | 0x00000100 |
| floating      | 1    | 0x00000200 |
| parallel      | 1    | 0x00000400 |
| heterogeneous | 1    | 0x00000800 |
| multi_channel | 1    | 0x00001000 |
| multi_column  | 1    | 0x00002000 |
| multi_row     | 1    | 0x00004000 |
| multi_frame   | 1    | 0x00008000 |
| saturation    | 1    | 0x00010000 |
| reserved      | 15   | 0xFFFE0000 |

Convenience functions **likely_<field>** and **likely_set_<field>** are provided for querying and editing the type.

### Type abbreviations
```Lua
null = likely.null
depth = likely.depth
signed = likely.signed
floating = likely.floating
parallel = likely.parallel
multi_channel = likely.multi_channel
multi_column = likely.multi_column
multi_row = likely.multi_row
multi_frame = likely.multi_frame
saturation = likely.saturation
reserved = likely.reserved
```

### Core functions
```Lua
closure = likely.closure
compile = likely.compile
expression = likely.expression
replace = likely.replace

new = closure({ likely.new, likely.f32, 1, 1, 1, 1, 0, false },
              { "Create an uninitialized matrix", "type", "channels", "columns", "rows", "frames", "data", "copy" })

scalar = closure({ likely.scalar, nil },
                 { "Create and initialize a single-dimension matrix from a number", "number" })

read = closure({ likely.read, nil },
               { "Create a matrix from a file", "file_name" })

show = closure({ likely.show, nil, "" },
               { "Display a value", "value", "name" })

function chain(x,y)
  return function(w) return y(x(w)) end
end
```

### Arguments
```Lua
arg = closure({ function(n) return { "arg", n } end, nil, nil },
              { "Function argument", "index" })
```

### Arithmetic
```Lua
add = closure({ function(lhs, rhs) return { "+", lhs, rhs } end, nil, nil },
              { "Arithmetic addition", "lhs", "rhs" })

sub = closure({ function(lhs, rhs) return { "-", lhs, rhs } end, nil, nil },
              { "Arithmetic subtraction", "lhs", "rhs" })

mul = closure({ function(lhs, rhs) return { "*", lhs, rhs } end, nil, nil },
              { "Arithmetic multiplication", "lhs", "rhs" })

div = closure({ function(lhs, rhs)
                  if rhs == 0 then
                    error("Denominator is zero!")
                  else
                    return { "/", lhs, rhs }
                  end
                end, nil, nil },
              { "Arithmetic division", "lhs", "rhs" })
```

### Math
```Lua
sqrt = closure({ function(x) return { "sqrt", x } end, nil },
               { "Square root", "operand" })

powi = closure({ function(base, iexp) return { "powi", base, iexp } end, nil, nil },
               { "Integer power", "base", "iexp" })

sin = closure({ function(x) return { "sin", x } end, nil },
              { "Sine", "radians" })

cos = closure({ function(x) return { "cos", x } end, nil },
              { "Cosine", "radians" })

pow = closure({ function(base, exp) return { "pow", base, exp } end, nil, nil },
              { "Power", "base", "exp" })

exp = closure({ function(x) return { "exp", x } end, nil },
              { "Base-e exponential", "exponent" })

exp2 = closure({ function(x) return { "exp2", x } end, nil },
               { "Base-2 exponential", "exponent" })

log = closure({ function(x) return { "log", x } end, nil },
              { "Natural logarithm", "operand" })

log10 = closure({ function(x) return { "log10", x } end, nil },
                { "Base-10 logarithm", "operand" })

log2 = closure({ function(x) return { "log2", x } end, nil },
               { "Base-2 logarithm", "operand" })

fma = closure({ function(a, b, c) return { "fma", a, b, c } end, nil, nil, nil },
              { "Fused multiply-add (a*b+c)", "a", "b", "c" })

fabs = closure({ function(x) return { "fabs", x } end, nil },
               { "Floating absolute value", "operand" })

copysign = closure({ function(magnitude, sign) return { "copysign", magnitude, sign } end, nil, nil },
                   { "Floating copy sign", "magnitude", "sign" })

floor = closure({ function(x) return { "floor", x } end, nil },
                { "Floating floor", "operand" })

ceil = closure({ function(x) return { "ceil", x} end, nil },
               { "Floating ceil", "operand" })

trunc = closure({ function(x) return { "trunc", x } end, nil },
                { "Floating round toward zero", "operand" })

rint = closure({ function(x) return { "rint", x } end, nil },
               { "Floating round to nearest integer", "operand" })

nearbyint = closure({ function(x) return { "nearbyint", x } end, nil },
                    { "Floating round to nearest integer", "operand" })

round = closure({ function(x) return { "round", x } end, nil },
                { "Floating round to nearest integer", "operand" })
```

### Operators
```Lua
for k, v in ipairs({ new(), arg(0) }) do
  local mt = getmetatable(v)
  mt.__add = function(lhs, rhs) return add(lhs, rhs) end
  mt.__sub = function(lhs, rhs) return sub(lhs, rhs) end
  mt.__mul = function(lhs, rhs) return mul(lhs, rhs) end
  mt.__div = function(lhs, rhs) return div(lhs, rhs) end
  mt.__pow = function(lhs, rhs) return pow(lhs, rhs) end
end

i = { "i" }
c = { "c" }
x = { "x" }
y = { "y" }
t = { "t" }
local mt = getmetatable(arg(0))
for k, v in ipairs({i, c, x, y, t}) do
  setmetatable(v, mt)
end
mt = nil
```

### Casting
```Lua
cast = closure({ function(x, type) return { "cast", x, type } end, nil, nil },
               { "Convert matrix to another type", "matrix", "type" })

type = closure({ function(x) return { "type", x } end, nil },
               { "Extract the matrix type", "matrix" })

set = closure({ function(matrix, value) return cast(value, type(matrix)) end, nil, nil },
              { "Assignment", "matrix", "value" })

u8  = closure({ function(x) return cast(x, likely.u8) end, nil, type = likely.u8 },
              { "Convert matrix to type u8", "matrix" })

u16 = closure({ function(x) return cast(x, likely.u16) end, nil, type = likely.u16 },
              { "Convert matrix to type u16", "matrix" })

u32 = closure({ function(x) return cast(x, likely.u32) end, nil, type = likely.u32 },
              { "Convert matrix to type u32", "matrix" })

u64 = closure({ function(x) return cast(x, likely.u64) end, nil, type = likely.u64 },
              { "Convert matrix to type u64", "matrix" })

i8  = closure({ function(x) return cast(x, likely.i8) end, nil, type = likely.i8 },
              { "Convert matrix to type i8", "matrix" })

i16 = closure({ function(x) return cast(x, likely.i16) end, nil, type = likely.i16 },
              { "Convert matrix to type i16", "matrix" })

i32 = closure({ function(x) return cast(x, likely.i32) end, nil, type = likely.i32 },
              { "Convert matrix to type i32", "matrix" })

i64 = closure({ function(x) return cast(x, likely.i64) end, nil, type = likely.i64 },
              { "Convert matrix to type i64", "matrix" })

f16 = closure({ function(x) return cast(x, likely.f16) end, nil, type = likely.f16 },
              { "Convert matrix to type f16", "matrix" })

f32 = closure({ function(x) return cast(x, likely.f32) end, nil, type = likely.f32 },
              { "Convert matrix to type f32", "matrix" })

f64 = closure({ function(x) return cast(x, likely.f64) end, nil, type = likely.f64 },
              { "Convert matrix to type f64", "matrix" })
```

### Comparison
```Lua
lt = closure({ function(lhs, rhs) return { "<", lhs, rhs } end, nil, nil },
             { "Less than", "lhs", "rhs" })

le = closure({ function(lhs, rhs) return { "<=", lhs, rhs } end, nil, nil },
             { "Less than or equal to", "lhs", "rhs" })

gt = closure({ function(lhs, rhs) return { ">", lhs, rhs } end, nil, nil },
             { "Greater than", "lhs", "rhs" })

ge = closure({ function(lhs, rhs) return { ">=", lhs, rhs } end, nil, nil },
             { "Greater than or equal to", "lhs", "rhs" })

eq = closure({ function(lhs, rhs) return { "==", lhs, rhs } end, nil, nil },
             { "Equal to", "lhs", "rhs" })

ne = closure({ function(lhs, rhs) return { "!=", lhs, rhs } end, nil, nil },
             { "Not equal to", "lhs", "rhs" })
```

### Conditionals
```Lua
select = closure({ function(c, t, f) return { "select", c, t, f } end, nil, nil, nil },
                 { "Conditional selection", "condition", "t", "f" })

threshold = closure({ function(x, t) return select(gt(x, t), 1, 0) end, nil, nil },
                    { "Binary threshold", "operand", "threshold" })
```

### Closures
```Lua
let = closure({ function(d, e) return { "let", d, e } end, nil, nil },
              { "Introduce variables", "definitions", "expression" })
```
