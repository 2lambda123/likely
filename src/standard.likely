Likely Kernel Library
=====================

 > An image recognition runtime for heterogenous architectures.
 > -- @jklontz

## Introduction
Welcome to the documentation and source code for _Likely_, the image recognition programming language!

### Principles
 - Heterogeneous hardware architecture support
 - Efficient syntax for feature representation and statistical learning
 - Immediate visual feedback during algorithm development
 - Embeddable into other projects and languages
 - Free open source software

### Help
We try to keep this document complete and correct. However, should you run into trouble, please feel free to ask questions on our [mailing list](https://groups.google.com/forum/#!forum/likely-dev) or report bugs on our [issue tracker](https://github.com/biometrics/likely/issues).

#### About This Document
Likely draws inspiration from Knuth's literate programming, as this file is also the [source code](src/standard.likely) for the Likely standard library. Likely supports [Github Flavored Markdown](https://help.github.com/articles/github-flavored-markdown) (GFM) syntax, and the Likely runtime will automatically extract and execute _code blocks_ found in GFM source files.

### Background
The software engineering of a complex system is often facilitated by a _Domain Specific Language_ (DSL) whose syntax is designed to concisely and efficiently solve problems frequently encountered in the domain. While many technical communities rely on DSLs, we believe there currently exists no suitable language for image recognition research. As a consequence, most libraries and applications are written in either _C++_ or _MATLAB_, neither of which simultaneously respect both the engineer's time and the hardware's compute capability.

> We believe a DSL for image recognition is essential to express algorithms that are currently too complex to implement in a "low-level" language and too slow to execute in a "high-level" language.

### Portability
Likely is built on top of the _Low Level Virtual Machine_ (LLVM) compiler infrastructure using a portable subset of ISO C++11, which means it runs [everywhere](http://llvm.org/docs/GettingStarted.html#hardware) LLVM does. Algorithms execute natively on single CPU threads via the LLVM _Machine Code Just-In-Time_ (MCJIT) compiler, multi-core CPUs via a custom OpenMP-like backend, and GPUs and coprocessors via _OpenCL_ or _CUDA_.

### Speed
Likely relies on powerful and well established LLVM compiler infrastructure to make function execution as fast as possible. Since compilation is held off until runtime, functions automatically take advantage of all instruction set extensions available on the host processor. In reality, compilation is delayed until a function is called for the first time, enabling optimization opportunities that are impossible in conventional image processing libraries. The entire premise of Likely is hinged on the observation that for image processing applications

> while kernels must be written generically to handle any matrix type, at runtime they tend to be executed repeatedly on the same type.

The repeated execution of a kernel with the same matrix type means that branching to handle different data types is unnecessary, entire loops and code blocks can be eliminated, and many values that would be runtime parameters instead become compile time constants. For these reasons, we expect Likely kernels to be faster than equally generic statically compiled code.

### Why not C++?
As image recognition engineers, we desire a curated set of image processing functions from which to compose sophisticated algorithms. Despite the multi-paradigm virtues of C++, it is extraordinarily difficult to provide library routines that are both generic and efficient. For example, consider the following library function for adding two vectors:

```C++
void add(const float *a, const float *b, float *c, unsigned int n) {
    for (unsigned int i = 0; i < n; i++)
        c[i] = a[i] + b[i];
}
```

#### Pointer Aliasing
While this function is simple, it is neither particularly fast nor generic. A popular assumption made in numerical libraries is that pointers never _alias_. In other words, variables _a_, _b_ and _c_ point to distinct non-overlapping regions in memory. The C language specification states that pointers may alias, so the compiler must insert a runtime check when vectorizing loops. This is the primary reason why [Fortran is faster than C](http://stackoverflow.com/a/146186). While C has since introduced the _restrict_ keyword to specify pointers that do not alias, this keyword is not supported in the C++:

```C++
// Valid C, invalid C++
void add(const float * restrict a, const float * restrict b, float * restrict c, unsigned int n) {
    for (unsigned int i = 0; i < n; i++)
        c[i] = a[i] + b[i];
}
```

#### Generics
Different image processing operations may operate on different data types, so we might try to generalize our function using templates:

```C++
template <typename T>
void add(const T *a, const T *b, T *c, unsigned int n) {
    for (unsigned int i = 0; i < n; i++)
        c[i] = a[i] + b[i];
}
```

However, what if we would like _a_ or _b_ to be a numerical constant? Or _c_ to be a different type?

_<To Be Continued>_

#### Why not MATLAB?
_<To Be Continued>_

## C API
C/C++ projects should `#include <likely.h>` and link against the `likely` library. `LikelyConfig.cmake` is provided in `share/likely/` as a convenience to CMake developers. Likely definitions are prefixed with `likely_` and use a `lowercase_underscore` naming convention. Consider taking a moment to skim the [header file](include/likely.h).

### The Matrix Struct
The `likely_mat`, or _matrix_, is only struct in the API and serves as the input and output for all function invocations:

| Field    | Type           | Description                       |
|----------|----------------|-----------------------------------|
| data     | likely_data    | Pointer to the buffer of elements |
| d_ptr    | likely_private | Used for internal bookkeeping     |
| channels | likely_size    | Matrix dimension                  |
| columns  | likely_size    | Matrix dimension                  |
| rows     | likely_size    | Matrix dimension                  |
| frames   | likely_size    | Matrix dimension                  |
| type     | likely_type    | Matrix type                       |

The last five fields (_channels_, _columns_, _rows_, _frames_, and _type_) are collectively referred to as the matrix _header_. In contrast to most image processing libraries which tend to feature 3-dimensional matrices (channels, columns, rows), Likely includes a fourth dimension, frames, in order to facilitate processing videos or collections of images.

#### Element Access
By convention, element layout in the data buffer with resepect to decreasing spatial locality is _channel_, _column_, _row_, _frame_. Thus an element at channel _c_, column _x_, row _y_, and frame _t_, can be retrieved like:
```C++
float likely_get_element(likely_mat m, likely_size c, likely_size x, likely_size y, likely_size t)
{
    likely_size columnStep = m->channels;
    likely_size rowStep = m->channels * columnStep;
    likely_size frameStep = m->rows * rowStep;
    likely_size index = t*frameStep + y*rowStep + x*columnStep + c;
    assert(likely_type(m) == likely_type_f32);
    return reinterpret_cast<float*>(m->data)[index];
}
```

Convenience functions `likely_element` and `likely_set_element` are provided for individual element access. These functions are inefficient for iterating over a large numbers of elements due to the repeated index calculations, and their use is suggested only for debugging purposes or when the matrix is known to be small.

#### Matrix Type
As suggested earlier, `likely_type` plays a critical role in determining how to process matricies. The type is a 4-byte _bit field_ that encodes what data type the matrix is and how/where it should be processed. It also specifies knowledge used to optimized code generation and by removing unneccesary indexing, looping, and branching.

Here is the layout of the bits in `likey_type`:

| Field         | Bits | Mask       |
|---------------|------|------------|
| depth         | 8    | 0x000000FF |
| signed        | 1    | 0x00000100 |
| floating      | 1    | 0x00000200 |
| parallel      | 1    | 0x00000400 |
| heterogeneous | 1    | 0x00000800 |
| multi_channel | 1    | 0x00001000 |
| multi_column  | 1    | 0x00002000 |
| multi_row     | 1    | 0x00004000 |
| multi_frame   | 1    | 0x00008000 |
| saturation    | 1    | 0x00010000 |
| reserved      | 15   | 0xFFFE0000 |

Convenience functions `likely_<field>` and `likely_set_<field>` are provided for querying and editing the type.

### Type abbreviations
```Lua
null = likely.null
depth = likely.depth
signed = likely.signed
floating = likely.floating
u8 = likely.u8
u16 = likely.u16
u32 = likely.u32
u64 = likely.u64
i8 = likely.i8
i16 = likely.i16
i32 = likely.i32
i64 = likely.i64
f16 = likely.f16
f32 = likely.f32
f64 = likely.f64
parallel = likely.parallel
multi_channel = likely.multi_channel
multi_column = likely.multi_column
multi_row = likely.multi_row
multi_frame = likely.multi_frame
saturation = likely.saturation
reserved = likely.reserved

i = "i"
c = "c"
x = "x"
y = "y"
t = "t"
```

### Core functions
```Lua
function chain(x,y)
  return function(w) return tostring(y{tostring(x{w})}) end
end

closure = likely.closure

new = closure(
  nil,
  "Create an empty matrix",
  {{"type", "matrix type", f32},
   {"channels", "matrix channels", 1},
   {"columns", "matrix columns", 1},
   {"rows", "matrix rows", 1},
   {"frames", "matrix frames", 1},
   {"data", "address of existing data buffer", 0},
   {"copy", "copy the data buffer", false}},
  likely.new)

scalar = closure(
  nil,
  "Create a matrix from a number",
  {{"value", "matrix value"}},
  likely.scalar)

read = closure(
  nil,
  "Create a matrix from a file",
  {{"file_name", "path to file on disk"}},
  likely.read)

compile = closure(
  nil,
  "Create kernel",
  {{"function", "function expression"}},
  likely.compile)
```

### Utility functions
```Lua
function likely.s(...)
  return "(" .. table.concat({...}, " ") .. ")"
end
```

### Arithmetic
```Lua
set = closure(
  function(value, matrix)
    return value
  end,
  "Assignment",
  {{"value", "numerical constant"},
   {"matrix", "used to determine output size and type"}})

add = closure(
  function(rhs, lhs) return likely.s("+", lhs, rhs) end,
  "Arithmetic addition",
  {{"rhs", "right hand side"},
   {"lhs", "left hand side"}})

subtract = closure(
  function(rhs, lhs) return likely.s("-", lhs, rhs) end,
  "Arithmetic subtraction",
  {{"rhs", "right hand side"},
   {"lhs", "left hand side"}})

multiply = closure(
  function(rhs, lhs) return likely.s("*", lhs, rhs) end,
  "Arithmetic multiplication",
  {{"rhs", "right hand side"},
   {"lhs", "left hand side"}})

divide = closure(
  function(rhs, lhs)
    if rhs == 0 then
      error("Denominator is zero!")
    else
      return likely.s("/", lhs, rhs)
    end
  end,
  "Arithmetic division",
  {{"rhs", "left hand side (denominator)"},
   {"lhs", "right hand side (numerator)"}})
```

### Math
```Lua
sqrt = closure(
  function(x) return likely.s("sqrt", x) end,
  "Square root: f(x) = x ** 0.5",
  {{"x", "operand"}})

powi = closure(
  function(n, x) return likely.s("powi", x, n) end,
  "Integer power: f(x) = x ** n",
  {{"x", "base"},
   {"n", "integer exponent"}})

sin = closure(
  function(x) return likely.s("sin", x) end,
  "Sine: f(x) = sin(x)",
  {{"x", "radians"}})

cos = closure(
  function(x) return likely.s("cos", x) end,
  "Cosine: f(x) = cos(x)",
  {{"x", "operand"}})

pow = closure(
  function(n, x) return likely.s("pow", x, n) end,
  "Power: f(x) = x ** n",
  {{"x", "base"},
   {"n", "exponent"}})

exp = closure(
  function(x) return likely.s("exp", x) end,
  "Base-e exponential: f(x) = e ** x",
  {{"x", "exponent"}})

exp2 = closure(
  function(x) return likely.s("exp2", x) end,
  "Base-2 exponential: f(x) = 2 ** x",
  {{"x", "exponent"}})

log = closure(
  function(x) return likely.s("log", x) end,
  "Natural logarithm: f(x) = log_e(x)",
  {{"x", "operand"}})

log10 = closure(
  function(x) return likely.s("log10", x) end,
  "Base-10 logarithm: f(x) = log_10(x)",
  {{"x", "operand"}})

log2 = closure(
  function(x) return likely.s("log2", x) end,
  "Base-2 logarithm: f(x) = log_2(x)",
  {{"x", "operand"}})

fma = closure(
  function(a, c, x) return likely.s("fma", a, x, c) end,
  "Fused multiply-add: f(a, b, x) = a * x + c",
  {{"a", "operand"},
   {"c", "operand"},
   {"x", "operand"}})

fabs = closure(
  function(x) return likely.s("fabs", x) end,
  "Floating absolute value: f(x) = |x|",
  {{"x", "operand"}})

copysign = closure(
  function(s, m) return likely.s("copysign", m, s) end,
  "Floating copy sign: f(x) = copysign(m, s)",
  {{"s", "value containing sign"},
   {"m", "value containing magnitude"}})

floor = closure(
  function(x) return likely.s("floor", x) end,
  "Floating floor: f(x) = floor(x)",
  {{"x", "operand"}})

ceil = closure(
  function(x) return likely.s("ceil", x) end,
  "Floating ceil: f(x) = ceil(x)",
  {{"x", "operand"}})

trunc = closure(
  function(x) return likely.s("trunc", x) end,
  "Floating round toward zero: f(x) = x > 0 ? floor(x) : ceil(x)",
  {{"x", "operand"}})

rint = closure(
  function(x) return likely.s("rint", x) end,
  "Floating round to nearest integer: f(x) = rint(x)",
  {{"x", "operand"}})

nearbyint = closure(
  function(x) return likely.s("nearbyint", x) end,
  "Floating round to nearest integer: f(x) = nearbyint(x)",
  {{"x", "operand"}})

round = closure(
  function(x) return likely.s("round", x) end,
  "Floating round to nearest integer: f(x) = round(x)",
  {{"x", "operand"}})
```

### Casting
```Lua
cast = closure(
  function(type, x) return likely.s("cast", x, type) end,
  "Cast matrix to another type",
  {{"type", "Likely type"},
   {"x", "operand"}})
```

### Comparison
```Lua
lt = closure(
  function(rhs, lhs) return likely.s("<", lhs, rhs) end,
  "Check if lhs is less than rhs",
  {{"rhs", "right hand side"},
   {"lhs", "left hand side"}})

le = closure(
  function(rhs, lhs) return likely.s("<=", lhs, rhs) end,
  "Check if lhs is less than or equal to rhs",
  {{"rhs", "right hand side"},
   {"lhs", "left hand side"}})

gt = closure(
  function(rhs, lhs) return likely.s(">", lhs, rhs) end,
  "Check if lhs is greater than rhs",
  {{"rhs", "right hand side"},
   {"lhs", "left hand side"}})

ge = closure(
  function(rhs, lhs) return likely.s(">=", lhs, rhs) end,
  "Check if lhs is greater than or equal to rhs",
  {{"rhs", "right hand side"},
   {"lhs", "left hand side"}})

eq = closure(
  function(rhs, lhs) return likely.s("==", lhs, rhs) end,
  "Check if lhs is equal to rhs",
  {{"rhs", "right hand side"},
   {"lhs", "left hand side"}})

ne = closure(
  function(rhs, lhs) return likely.s("!=", lhs, rhs) end,
  "Check if lhs is not equal to rhs",
  {{"rhs", "right hand side"},
   {"lhs", "left hand side"}})
```

### Image Processing
```Lua
threshold = closure(
  function(val, x) return likely.s("threshold", x, val) end,
  "Binary threshold",
  {{"val", "threshold"},
   {"x", "operand"}})
```
