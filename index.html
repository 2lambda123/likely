<!DOCTYPE html>
<?xml-stylesheet type="text/xsl" href="http://www.w3.org/Math/XSL/mathml.xsl"?>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Likely</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Literate Kernel Library">
  <meta name="author" content="Josh Klontz">

  <link href="bootstrap/css/bootstrap.css" rel="stylesheet">
  <style>
    body {
      padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
    }
  </style>
  <link href="bootstrap/css/bootstrap-responsive.css" rel="stylesheet">

  <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
  <!--[if lt IE 9]>
    <script src="../assets/js/html5shiv.js"></script>
  <![endif]-->

  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

  <link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet"/>
  <script type="text/javascript" src="google-code-prettify/prettify.js"></script>
</head>

<body onload="prettyPrint()">
  <div class="navbar navbar-inverse navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container"> <div class="row"> <div class="span12">
        <a class="brand" href="#">Likely</a>
        <ul class="nav">
          <li><a href="https://github.com/biometrics/likely">Source</a></li>
          <li><a href="https://github.com/jklontz">Author</a></li>
        </ul>
        <ul class="nav pull-right">
          <li><a class="pull-right" href="LICENSE.txt">Licensed under Apache 2.0 &copy; 2013 Joshua C. Klontz</a></li>
        </ul>
      </div> </div> </div>
    </div>
  </div>

  <div class="container"> <div class="row"> <div class="span12">
    <h1 id="literate_kernel_library">Literate Kernel Library</h1>
    <p class="lead">Beautiful image processing functions for heterogenous architectures.</p>
    <h2>Table of Contents</h2>
    <ul>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#installation">Installation</a></li>
      <li><a href="#api_overview">API Overview</a></li>
      <ul>
        <li><a href="#the_matrix_struct">The Matrix Struct</a></li>
        <li><a href="#functions_and_kernels">Functions and Kernels</a></li>
      </ul>
      <li><a href="#algorithm_syntax">Algorithm Syntax</a></li>
      <ul>
        <li><a href="#function_definition">Function Definition</a></li>
        <li><a href="#function_request">Function Request</a></li>
      </ul>
      <li><a href="#standard_library">Standard Library</a></li>
      <ul>
        <li><a href="#nullary_functions">Nullary Functions</a></li>
        <li><a href="#unary_functions">Unary Functions</a></li>
        <li><a href="#binary_functions">Binary Functions</a></li>
        <li><a hreg="#ternary_functions">Ternary Functions</a></li>
      </ul>
    </ul>
    <h2 id="introduction">Introduction</h2>
    <p>Welcome to the documentation <i>and source code</i> for <i>Likely</i> the literate kernel library!
       Simply stated, the goals of Likely are to provide image processing and machine learning functions that are:
      <ul>
        <li>executable everywhere.</li>
        <li>perfectly optimized.</li>
        <li>uncompromisingly elegant.</li>
      </ul>
    </p>
    <h3 id="executable_everywhere">Executable Everywhere</h3>
    <p>Likely is written in a portable subset of <i>ISO C++11</i> and depends only on <i>LLVM</i> which means it runs <a href="http://llvm.org/docs/GettingStarted.html#hardware">everywhere LLVM does</a>.
      Kernels execute natively on single CPU threads via the LLVM <i>Just-In-Time</i> (JIT) compiler, multi-core CPUs with <i>std::thread</i>, and <i>OpenCL</i> compatible GPUs and coprocessors.
    </p>
    <h3 id="perfectly_optimized">Perfectly Optimized</h3>
    <p>Likely relies on the powerful and well established LLVM optimization passes to make kernel execution as fast as possible.
      Since compilation is held off until runtime, kernels are optimized to take advantage of all instruction set extensions available on the host processor.
      In reality, compilation is delayed until a function is called for the first time, enabling optimization opportunities that are impossible in conventional image processing libraries.
      The entire premise of Likely is hinged on the observation that for image processing applications
      <blockquote>
        <p>while kernels must be written generically to handle any matrix type, at runtime they tend to be executed repeatedly on the same type.</p>
      </blockquote>
      The repeated execution of a kernel with the same matrix type means that branching to handle different data types is unnecessary, entire loops and code blocks can be eliminated, and many values that would be runtime parameters instead become compile time constants.
      For this reason, it's not uncommon for Likely kernels to be <i>faster</i> than equally generic <tt>C</tt> code.
    </p>
    <p id="hash_introduction">In Likely, a matrix's type is referred to as its <i><a href="#the_matrix_hash">hash</a></i>, encompassing its data type (<tt>integer</tt> or <tt>floating point</tt>), depth (<tt>8</tt>, <tt>16</tt>, <tt>32</tt>, or <tt>64</tt> bits), computation location (<tt>serial CPU</tt>, <tt>parallel CPU</tt>, or <tt>heterogeneous coprocessor</tt>), and its <tt>single-dimension</tt> axes.
      Likely functions check the input's hash against the currently compiled kernel's hash and recompile on a mismatch.
      In this way,
      <blockquote>
        <p>all the logic needed to handle different matrix types is reduced to a single 16-bit integer comparison which branch prediction can optimize out.</p>
      </blockquote>
    </p>
    <h3 id="uncompromisingly_elegant">Uncompromisingly Elegant</h3>
    <p>Likely is inspired by Donald Knuth's <i>literate programming</i>.
      It is a <i>literate</i> kernel library because
      <blockquote>
        <p>all the kernels documented on this webpage are also the source code for the library.</p>
      </blockquote>
      In fact, this webpage is compiled into the Likely library and parsed at runtime to extract kernel definitions.
      You can access this content for yourself with <code class="prettyprint lang-c">const char *this_webpage = likely_index_html();</code>.
    </p>
    <p>Kernels are written in \(\LaTeX\) allowing for the same high-quality rendering available in academic publications.</p>
    <h2 id="installation">Installation</h2>
    <p>The following sections discuss how to build and incorporate Likely into your own project.</p>
    <h3 id="build_instructions">Build Instructions</h3>
    <p>Likely uses the <i>CMake</i> (>= 2.8.9) build system and will automatically download and compile its LLVM dependency.</p>
    <pre>$ git clone https://github.com/biometrics/likely.git<br>$ cd likely<br>$ mkdir build<br>$ cd build<br>$ cmake ..<br>$ make -j4 # First time builds LLVM<br>$ cmake ..<br>$ make -j4 # Second time builds Likely</pre>
    <p>Unit tests are an optional build flag whereby kernels are compared against equivalent <i>OpenCV</i> functions for correctness and speed.
      The build system will automatically download and compile OpenCV.
    </p>
    <pre>$ cmake -D BUILD_TESTING=ON ..<br>$ make -j4 # First time builds OpenCV<br>$ cmake ..<br>$ make -j4 # Second time builds tests<br>$ make test</pre>
    <p>Installation and packaging work as expected.</p>
    <pre>$ make install<br>$ cpack -G TGZ</pre>
    <h3 id="usage">Usage</h3>
    <p>C/C++ projects should <code class="prettyprint lang-c">#include &lt;likely.h&gt;</code> and link against the <code>likely</code> shared library.
      <tt>FindLikely.cmake</tt> is provided as a convenience to CMake developers.
    </p>
    <h2 id="api_overview">API Overview</h2>
    <p>Likely is a C API that provides an optional C++ wrapper.
      Definitions in the C API are prefixed with <tt>likely_</tt> and use a <tt>lowercase_underscore</tt> naming convention.
      Definitions in the C++ wrapper live in <tt>namespace likely</tt> and use a <tt>camelCase</tt> naming convention.
      Consider taking a moment to skim the <a href="likely.h">header file</a>.
    </p>
    <h3 id="the_matrix_struct">The Matrix Struct</h3>
    <p>The <tt>likely_matrix</tt> is only struct in the API and serves as the input and output for all kernel invocations.
      The <tt>likely_matrix</tt>, hereafter referred to as the <i>matrix</i>, has the following fields:
    </p>
    <pre class="prettyprint lang-c">uint8_t *data; // Pointer to the buffer of elements<br>uint32_t channels, columns, rows, frames; // Dimensions<br>uint16_t hash; // Data type</pre>
    <p>The five fields excepting the <i>data</i> pointer (<i>channels</i>, <i>columns</i>, <i>rows</i>, <i>frames</i>, and <i>hash</i>) are collectively referred to as the matrix <i>header</i>.
    In contrast to most image processing libraries which tend to feature 3-dimensional matrices (channels, columns, rows), Likely includes a fourth dimension, frames, in order to facilitate processing videos or collections of images.
    <h4 id="element_access">Element Access</h4>
    <p>By convention, element layout in the data buffer with resepect to decreasing spatial locality is <i>channel</i>, <i>column</i>, <i>row</i>, <i>frame</i>.
      Thus an element at channel <i>c</i>, column <i>x</i>, row <i>y</i>, and frame <i>t</i>, or (c, x, y, t), can be indexed into like:
    </p>
    <pre class="prettyprint lang-c">likely_matrix *m = foo();<br>int columnStep = m->channels;<br>int rowStep = m->channels * columnStep;<br>int frameStep = m->rows * rowStep;<br>int index = t*frameStep + y*rowStep + x*columnStep + c;<br>assert(likely_type(m) == likely_matrix::f64);<br>double element = ((double*)m->data)[index];</pre>
    <p>Convenience functions <code class="prettyprint lang-c">double likely_element(...)</code> and <code class="prettyprint lang-c">void likely_set_element(...)</code> are provided for individual element access.
      Using the convenience functions is inefficient when iterating over a large numbers of elements due to the repeated index calculation, and their use is generally suggested only for debugging purposes or when the matrix is known to be small.</p>
    <h4 id="the_matrix_hash">The Matrix Hash</h4>
    <p>As suggested in the <a href="#hash_introduction">introduction</a>, the matrix hash plays a critical role in determining how to process the matrix.
      The hash is a 2-byte <i>bit field</i> that encodes what data type the matrix is are where it should be processed.
      It also specifies which, if any, of the channels, columns, rows, and frames of the matrix are length 1.
      This knowledge is used during kernel compilation to simplify element access algebra and remove unneccesary loops and branches.
    </p>
    <p>The layout of the bits in the hash is documented below.</p>
    <table class="table table-bordered table-condensed table-hover table-striped">
      <caption>Matrix Hash Bit Field Layout</caption>
      <thead>
        <tr><th>Field</th><th>Bits</th><th>Enum</th><th>Mask</th></tr>
      </thead>
      <tbody>
        <tr><td>Depth</td><td>8</td><td>likely_matrix::Depth</td><td>0x00FF</td></tr>
        <tr><td>Signed</td><td>1</td><td>likely_matrix::Signed</td><td>0x0100</td></tr>
        <tr><td>Floating</td><td>1</td><td>likely_matrix::Floating</td><td>0x0200</td></tr>
        <tr><td>Type (= Depth | Signed | Floating)</td><td>10</td><td>likely_matrix::Type</td><td>0x03FF</td></tr>
        <tr><td>Parallel</td><td>1</td><td>likely_matrix::Parallel</td><td>0x0400</td></tr>
        <tr><td>Heterogeneous</td><td>1</td><td>likely_matrix::Heterogeneous</td><td>0x0800</td></tr>
        <tr><td>Single Channel</td><td>1</td><td>likely_matrix::SingleChannel</td><td>0x1000</td></tr>
        <tr><td>Single Column</td><td>1</td><td>likely_matrix::SingleColumn</td><td>0x2000</td></tr>
        <tr><td>Single Row</td><td>1</td><td>likely_matrix::SingleRow</td><td>0x4000</td></tr>
        <tr><td>Single Frame</td><td>1</td><td>likely_matrix::SingleFrame</td><td>0x8000</td></tr>
      </tbody>
    </table>
    <p>Logic for querying and editing the hash is simplified with the following <i>inline</i> convenience functions.</p>
    <table class="table table-bordered table-condensed table-hover table-striped">
      <caption>Matrix Hash Convenience Functions</caption>
      <thead>
        <tr><th>Field</th><th>Type</th><th>Getter</th><th>Setter</th></tr>
      </thead>
      <tbody>
        <tr><td>Depth</td><td>int</td><td>likely_depth</td><td>likely_set_depth</td></tr>
        <tr><td>Signed</td><td>bool</td><td>likely_is_signed</td><td>likely_set_signed</td></tr>
        <tr><td>Floating</td><td>bool</td><td>likely_is_floating</td><td>likely_set_floating</td></tr>
        <tr><td>Type</td><td>int</td><td>likely_type</td><td>likely_set_type</td></tr>
        <tr><td>Parallel</td><td>bool</td><td>likely_is_parallel</td><td>likely_set_parallel</td></tr>
        <tr><td>Heterogeneous</td><td>bool</td><td>likely_is_heterogeneous</td><td>likely_set_heterogeneous</td></tr>
        <tr><td>Single Channel</td><td>bool</td><td>likely_is_single_channel</td><td>likely_set_single_channel</td></tr>
        <tr><td>Single Column</td><td>bool</td><td>likely_is_single_column</td><td>likely_set_single_column</td></tr>
        <tr><td>Single Row</td><td>bool</td><td>likely_is_single_row</td><td>likely_set_single_row</td></tr>
        <tr><td>Single Frame</td><td>bool</td><td>likely_is_single_frame</td><td>likely_set_single_frame</td></tr>
      </tbody>
    </table>
    <h3 id="functions_and_kernels">Functions and Kernels</h3>
    <p>While both functions and kernels are thought of as mathematical transforms on matrices, the two words have distinct definitions in Likely.
      <i>Functions</i> are exposed through the API and accept input matrices with arbitrary hashes.
      <i>Kernels</i> are JIT compiled to calculate the requested operation for a particular matrix hash.
      Kernels are managed automatically by functions and are hidden from the end user.
    </p>
    <p>All functions peform the following general steps:</p>
    <dl class="dl-horizontal">
      <dt>Hash Check</dt><dd>Compare the hash of the input against the hash of the currently loaded kernel, compile and load the correct kernel if they differ.</dd>
      <dt>Preallocation</dt><dd>Compute the header of the output from the header of the input.</dd>
      <dt>Allocation</dt><dd>Heap-allocate the output data buffer based on its elements and type.</dd>
      <dt>Kernel Invocation</dt><dd>Call the kernel with the input and output matricies.</dd>
    </dl>
    <h4 id="function_arity">Function Arity</h4>
    <p>There are four function types in Likely taking between zero and three input matrices.
      The number of input matrices a function accepts is referred to as its <i>arity</i>.
      All functions compute one output matrix that is passed by reference as the last argument.
      Each function arity has a <i>maker</i> function in the API for requesting paricular mathematical transforms of its type.
    </p>
    <table class="table table-bordered table-condensed table-hover table-striped">
      <caption>Maker Functions - The Core API</caption>
      <thead>
        <tr><th>Arity</th><th>Signature</th><th>Return Type</th></tr>
      </thead>
      <tbody>
        <tr><td>0</td><td>likely_make_nullary_function(const char *description)</td><td>likely_nullary_function</td></tr>
        <tr><td>1</td><td>likely_make_unary_function(const char *description)</td><td>likely_unary_function</td></tr>
        <tr><td>2</td><td>likely_make_binary_function(const char *description)</td><td>likely_binary_function</td></tr>
        <tr><td>3</td><td>likely_make_ternary_function(const char *description)</td><td>likely_ternary_function</td></tr>
      </tbody>
    </table>
    <p>Note that the return type of each maker is a function pointer that can be then called to perform the requested operation.</p>
    <pre class="prettyprint lang-c">typedef void (*likely_nullary_function)(likely_matrix *dst);<br>typedef void (*likely_unary_function)(const likely_matrix *src, likely_matrix *dst);<br>typedef void (*likely_binary_function)(const likely_matrix *srcA, const likely_matrix *srcB, likely_matrix *dst);<br>typedef void (*likely_ternary_function)(const likely_matrix *srcA, const likely_matrix *srcB, const likely_matrix *srcC, likely_matrix *dst);</pre>
    <p>As is true in the example below, most functions are either unary or binary.</p>
    <pre class="prettyprint lang-c">likely_matrix src = foo(); // Pre-initialized input matrix<br>likely_matrix dst; // Uninitialized output matrix<br>likely_unary_function multiply_add = likely_make_unary_function("madd(3,2)"); // Create a function that...<br>multiply_add(&src, &dst); // ...multiplies elements by three then adds two.</pre>
    <h2 id="algorithm_syntax">Expressing Algorithms</h2>
    <p>By this point all the entire API has been covered though you are probably still wondering how, exactly, to request functions and define new ones.
      Lets begin with how functions are defined, as once that is understood, it will become evident how they can be requested.
    </p>
    <h3 id="function_definition">Function Grammar</h3>
    <p>Like most programming language compilers, the Likely runtime follows three primary steps to compile code.</p>
    <ol>
      <li>Lexical Analysis</li>
      <li>Recursive Descent Parsing</li>
      <li>Code Generation</li>
    </ol>
    <h4>Lexical Analysis</h4>
    <p>Lexical analysis is the process whereby the source code is scanned for function definitions and broken up into the indivisible <i>tokens</i> that constitute keywords, variables, and operators.
      The contents of this file, <tt>index.html</tt>, is scanned at runtime for code that matches the following pattern.
    </p>
    <pre class="prettyprint lang-html">&lt;div class="likely"&gt;<br>  $$<i>Equation</i>$$<br>  &lt;h4&gt;<i>Name</i>&lt;small&gt;<i>Parameters</i>&lt;/small&gt;&lt;/h4&gt;<br>  &lt;p&gt;<i>Documentation</i>&lt;/p&gt;<br>&lt;/div&gt;</pre>
    <p>Together the <i>equation</i>, <i>name</i>, <i>parameters</i>, and <i>documentation</i> constitute a function <i>definition</i>. For example:</p>
    <pre class="prettyprint lang-html">&lt;div class="likely"&gt;<br>  $$a*src+b$$<br>  &lt;h4>madd&lt;small&gt;(a,b)&lt;/small&gt;&lt;/h4&gt;<br>  &lt;p&gt;Multiply-add.&lt;/p&gt;<br>&lt;/div&gt;</pre>
    The equation is tokenized with a greedy parsing strategy and the <a href="http://www.cplusplus.com/reference/regex/ECMAScript/">ECMAScript</a> regular expression <code>^\\s*([+\\-*/]|\\w+).*$</code>.
    <h3 id="function_request">Function Request</h3>
    <h2 id="standard_library">Standard Library</h2>
    All of the implemented functions.
    <h3 id="nullary_functions">Nullary Functions</h3>
    <h3 id="unary_functions">Unary Functions</h3>
    <ul class="thumbnails">
      <li class="thumbnail">
        <div class="likely">
          $$a*src+b$$
          <h4>madd<small>(a,b)</small></h4>
          <p>Multiply-add.</p>
        </div>
      </li>
    </ul>
    <h3 id="binary_functions">Binary Functions</h3>
    <h3 id="ternary_functions">Ternary Functions</h3>
  </div> </div> </div>
</body>

</html>
